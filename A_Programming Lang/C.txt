Topic :-
 - Intro 
 - Installation
 - C Program Structure
 - Comments
 - Keyword 
 - Identifiers
 - Variable 
 - Literals
 - Data Types
 - Input-Output(I/O)
 - Operator
 - Storage Classes
 - Control Flow (Condition | Loop | Statement | Switch Case)
 - Function
 - Array
 - Pointer



Intro :-
 - Developed by Dennis M. Ritchie at bell labs
 - First implmented in DEC PDP-11 Computer in 1972 and in 1978 Brain Kernigham and Dennis release Publicly(K&R)
 - Language Fromalized in 1988 ANSI(American National Standard Institute)
 - Unix totally written in C
 - Extension is .c
 - Case sensitive
 - C is compiler based language
 - Must contain main() function from when code start execution
 - 0 or getch() statement inside main() function is "Exit Status" of program
 - ;(SemiColon) is statement terminator for each individual statement
  


Installation :-
 gcc -v on linux to check
 MinGW  on windows


 
C Program Structure :- 
 - .c --> compiler --> .out(Executable Code) / .exe --> Output
 Preprocessor Directive :- Tell compiler Include library(stdio.h) file before going to actual compilation
 Function    - main() function from where program execution begin  
 Variables                  
 Statements & Expression
 Comment
 
 
Token      :- Token is either keyword, identifier, constant, string literal or symbol


Comment :- 
 - Ignored by compiler
 - Programmer add to make code easier to read and understand
 Type :- 
  //      - Single-line comment  
  /*..*/  - Multi-line comment 



Identifier :-
 - Set of Alphabets, letters and special character
 - Used to identify variable, function or any other user-defined item 
 
 Types of Identifier :-   
  CharacterSet       - A-Z,a-z 
  Digit              - 0 to 9     
  Special Character  - 31
  WhiteSpace Character - Blank Space, Horizontal Tab, Carriage Return and Form Feed   



Literals :- 
 - Representing fixed values
 Ex :-  1, 2.5, 'c' 

 Integer :-
  - Numeric literal(Number) without any fractional or exponential part
    octal       (base 8)  :- 021, 077 
    decimal     (base 10) :- 0, -8, 22
    Hexadecimal (base 16) :- 0x7f, 0x2a

 Floating :- Numeric literal that has either fractional or exponent form
  Ex :- -2.0, 0.00234, -0.22E-5 (E-5 = 10-5)

 Character :- Single character inside single quotation marks
  Ex :- 'a', 'm', 'F', '2', '}'

 Escape Sequence :- Characters with backslash which has special meaning
  \b - backspace      | \\ - Backslash              | \0 Null Character
  \f - formfeed       | \' - Single Quotation Mark  | \" - Double Quotation Mark
  \n - newline        | \r - return                 | \? - Quotation Mark    
  \t - Horizontal tab | \v - vertical tab

 String Literals :- Sequence of characters enclosed in double-quote marks 
  Ex :- "String" , "" ,  "    ", "S", 

 Constants :- Variable value cannot be changed once declared
  Ex :- const double PI = 3.14;
        #define LENGTH 10          - preprocessor 

 void :- Represents absence type


  
Variable :-
 - Name of memory location which store some data
 - extern keyword used to declare variable in any place
 - Declare variable multiple times but defined only once
 - Expression that refer to memory location are called "lvalue" expression
 - rvalue refer to data value that stored at particular memory location

 Ex :- 
  int intValue = 10; // declare variable with int type
  intValue = 10.10;  // Wrong cannot change int to float
  float a,v,c;       // Variablelist with no value
  int g = 10, n = 20;
  
 Rules :-
  - First letter either alphabet or underscore cannot use digit or any special character
  - Cannot use keyword
  - no comma/blank space
  - Name Must be unique
  - Case-sensitive 
  - No special character use other than _(Underscore)

 Scope :-
  - Scope defined variable or function can be accessible or not
  - Inside function or block variable called local variable while outside called global variable
  - Local variable only accessed inside function or block not accessible outside
  - Global variable access anywhere in program throughout program 
  - Local variable not initialized by system you must initialize it while global variable initialized automatically
 


Data Types :-
 - Determine type and size of variables data stored in memory
 - To Check size of variable use sizeof() operator Ex :- sizeof(variableName);
 - String and boolean not exist
  
 Built-in :- 1 byte = 8 bit, 1 kb = 1024 byte, 1mb = 1024kb    
  Type          Size     Range              Format Specifier    Example 
  char	       1 byte	−128 to 127         %c                  char test = 'B';
  short	       2 byte	−32,768 to 32,767                       short a = 10;
  int	         2 byte	−32,768 to 32,767   %d, %i              int id  = 0;            |  -5, 10;
  float	       4 byte                     %f                  float no = 22.442e2;    
  double	     8 byte                     %lf                 double no = 22.442e2;
  long int     4 byte                     %ld, %li            long a;
  long double	 10 byte                    %Lf                 long double d;
  unsigned int  4 byte	0 to 65,535       %u                  unsigned int x = 35;
  
  short int - %hd | unsigned int  - %u  
  long int  - %li | long long int - %lli
  unsigned long int	- %lu

 Types of modifier :-
  Signed   - Store both positive and negative number
  Unsigned - Store only positive number

 Derive Data Type :- Derived from primitive or built-in datatype referred as Derived Data Types
  Types :- Function, Arrays, Pointers, Reference

 User-Defined Data Types :- Defined by user are called user-defined data types
  Types :- Structure, Union, Enumeration, Typedef    

 Type Casting :-
  - Convert variable from one data type to another data type
  - Implicit conversion done by computer while explicitly casting done by cast operator
  Syntax :- (type_name) expression

  Example :-
    int sum = 17, count = 5;
    double mean;
    mean = (double) sum / count;
    printf("Value of mean : %f\n", mean );



Keyword :-
 - Special meaning for compiler that we can not used as identifier 
 - Must written in lower case
 - 32 keyword in C
  
 Keywords in ANSI C :-
  void     int        char    double  float  short	signed  unsigned  long	
  if       else       switch  case    break  continue goto
  for      while      do      return
  const    enum       extern  default
  auto	   register	  struct
  volatile static	    sizeof	typedef union
   


Operator :- 
 - Operator is symbol that operates on value or variable
 
 Arithmetic :- Perform Mathematical operation
  Ex :- +, -, *, /, %(Reminder), ++, //

 Assignment Operator :- Used for assign value to variable
  Ex :- =, +=, -=, *=, /=, %= , <<=, >>= , &=, ^= , |=

 Relational Operator :- If relation is true return 1 otherwise false(0)
  Ex :- ==, >=, <=, !=, >, <

 Logical Operator :- Return either 0 or 1 depending upon whether expression results true or false
  && - Logical AND return true if both condition is true
  || - Logical OR return true if any condition is true
  !  - Logical NOT return true if operand is 0

 BitWise Operator :- Perform bit-level operation
  &	Bitwise AND         |  |	Bitwise OR   | ^	Bitwise exclusive OR
  ~	Bitwise complement  |  <<	Shift left   | >>	Shift right

 Comma Operator :- Link related expressions together
  Ex :- int a, c = 5, d;

 sizeof() Operator :-
  - Unary operator that return size of data (constant, variables, array, structure, etc.)
  - Format Specifier %zu is used to print value

 Unary operator :- Works with single operand 
  Ex :- ++, -- 

 Other Operator :-
  ?: Ternary operator     | &  Reference operator | *  Dereference operator | -> Member selection



Input / Output(I/O) :-
 - C treats all devices as files
 - File pointer access file for reading and writing purpose

  Standard File	       File   Pointer	Device
  Standard input	    stdin	    Keyboard
  Standard output	    stdout	  Screen
  Standard error	    stderr	  Your Screen

 Output :-
  - printf() library function send formatted output on screen 
  - To use printf() library add :- #include<stdio.h> statement
  Ex :- printf("Bhavin") 

  - To print variable value use format specifier 
  int no = 5; 
  float no1 = 10.10;
  double no2 = 20.202;
  char ch = 'B';
  printf(" %d  %f  %lf  %c  %s ",no, no1, no2, ch, "String");


 Input :-
  - scanf() function read formatted input from standard input such as keyboards
  Ex :- 
  #include <stdio.h>
  int main()
  {
    int testInteger;
    float num1;
    double num2;
    char chr;
    scanf("%d", &testInteger);  // &testInteger get address of testInteger and user entered value stored in address
    scanf("%f %lf ", &num1 , &num2); // Multi-input from single line
    scanf("%c",&chr);   
    printf(" %d %f\n  %lf\n %c", testInteger, num1, num2, chr); 
    // Character itself is not stored Instead integer value (ASCII value) is stored
    return 0;
  }              


 getchar() and putchar() :-
  - int getchar(void) function read next available character from screen and return it as integer
  - int putchar(int c) put passed character on screen and return same character
  - getchar() read only single character at time while putchar() puts only single character at a time
  - Use method in loop for read more than one character from screen or display more than one character on screen
 
  Ex :-
   int c;
   printf( "Enter a value :");
   c = getchar( );
   printf( "\nYou entered: ");
   putchar( c ); 
  Output :-
   Enter a value : this is test
   You entered: t  


 gets() and puts() :-
  - char *gets(char *s) read line from stdin into buffer pointed by s until terminating newline or EOF(End of File)
  - int puts(const char *s) function write string 's' and 'a' trailing newline to stdout

  Ex :-
   char str[100];
   printf( "Enter a value :");
   gets(str);
   printf( "\nYou entered: ");
   puts(str);
  Output :-
   Enter value : this is test
   You entered : this is test


 scanf() and printf() :-
  - int scanf(const char *format,..) read input from stdin stream and scan input according to provided format
  - int printf(const char *format,..) write output to stdout stream and produce output according to provided format
  - Format can be simple constant string but able to specify %s, %d, %c, %f, etc.. 
  - scanf() expect input in same format as provided
  - Secondly while reading string scanf() stops reading as soon as it encounters space
  Ex :-
    char str[100];
    int i;
    printf( "Enter a value :");
    scanf("%s %d", str, &i);
    printf( "\nYou entered: %s %d ", str, i); 
  Output :-
    Enter a value : seven 7
    You entered: seven 7



Control Flow (Condition | Loop | Statement | Switch Case):- 

 Condition  :-
  If               :- if(expression){  //True code  }
  if...else        :- if(expression){  //True code  } else { //False code }
  if else ledder   :- if(expression){ //code } else if(expression){ //code } else { //False code}
  Nested If.. else :- if(expression){ if(expression){ //True code } else { //False code } } else{ //False code }
  Ternary          :- Condition ? True Code : False Code;     


 Loop :- 
  - Repeat block of code until specified condition is not false
  For Loop   :-  for(Initalization; Condition; Increment/Decrement){ //code }
  While Loop :-  while(expression){ //code  // Increment/Decrement } 
  Do..While  :-  do { //code // Increment/Decrement }while(expression)
   - Loop run at least one time in program
  

 Statement :-
  Break    :- Terminate loop immediately 
  Continue :- Skips current iteration of loop and continues with next iteration
 
  goto     :- 
   - Transfer Program control to specified label
   - label is identifier When goto statement is encountered
   - Control of program jumps to label: and starts executing code
   Syntax :- 
    goto label;
    label:
    statement;  
            
         
 Switch Case :-
  - Allow variable to be tested against list of values
  - Expression used in switch statement must have integral or enumerated type
  - Expression evaluated once and compared with values of each case label
  - If there is match, corresponding statement after matching label are executed otherwise default statement executed
  - Default statement is optional
  Syntax :- 
   switch(expression){
    case constant1:
      // Statement   
      break; 
                
    case constant2:
      // Statement   
      break; 

    default:
      // Statement
   } 



Function :-
 - Block of code that perform specific task
 - Every program must have main() function
 - Function declaration tell compiler about function name, return type and parameters
 - function definition provides actual function body
 

 Syntax :-
  return_type function_name(Parameter list){
    // function body
  }

 Call function :- function_name(Parameter) 
 Function Call by Value     :- Passing function arguments value
 Function Call by Reference :- Passing function arguments address


 Recursion :- 
  - Process of repeating items in self-similar way
  - If Program allow you to call function inside same function its called recursive
  
  Example :-
   void recursion() {
    recursion(); /* function calls itself */
   }


 Variable Arguments :-
  - C allow to define function which accept variable as number of parameters based on requirement
  - Use stdarg.h header file which provide functions and macros to implement functionality of variable argument
  Example :- 
   int func(int, ... ) {}
   int main() {
    func(1, 2, 3);
    func(1, 2, 3, 4);
   }

 
 Command-line Argument :-
  - Pass some values from command line 
  - Handled by main() function argument where argc refer to number of arguments passed and 
    argv[] is pointer array which points to each argument passed to program
  - argv[0] hold name of program itself 
  - argv[1] is pointer to first command line argument supplied 
  - *argv[n] is last argument 
  - If no argument supplied argc will be one and if pass one argument then argc is set at 2
  
  Example :-
   int main( int argc, char *argv[] ) {
    if( argc == 2 ) {
      printf("Argument supplied is %s\n", argv[1]);
    }
   }
  Output :-
   - $./a.out "testing1 testing2" // Command-line argument
   - The argument supplied is testing1 testing2
   


Array :-
 - Used to Store collection of same type data in contiguous manner in fixed-size memory
 - Array elements accessible via its index
 - lowest address corresponds to first element and highest address to last element
 Syntax :- type array_name[arraysize];  // Size must be Integer
 
 Example :- 
  int arr[10];                 // One-Dimensional array
  int arr[3] = {1,2,3};        // Initializing array 
  arr[2] = 2;                  // Initializing array with specified index
  - If element is greater than array size ArrayIndexOutOfBoundsException Throw
  int access_arr = arr[1];     // Access array element 
  
  int multi_arr[5][10];        // Two-Dimensional array - [Row][Column]
  int multi_arr[5][10] = {1,2,3,4,5,6,7,8,9,10,11,12,13};
  int val = multi_arr[2][5];
  
  int multi_arr[5][10][4]      // Multi-Dimensional array - [Row][Column][Dimension]


 Passing Array as Function Arguments :- 
  void myFunc(int *param)   |    (int param[10])    |   (int param[])


 Return Array From Function :- 
  int * myFunc()    



Pointer :-
 - Every variable has location and every location has its address which accessed using ampersand (&) Operator
 - Pointer is variable whose value is address of another variable
 Syntax :- type *variable_name;
 - * asterisk sign used to declare variable as pointer
 
 Example :- 
  int var = 10;
  int *ip; or int *ip = NULL; // Null pointer 0 value
  ip = &var; 
  printf("Access Value of Pointer variable", *ip); //10 - Normal ip print address and &var print variable address

 
 Pointer Arithmetic :- ++, --, +, - 
  Example :- 1000 | 1004

 Pointer Comparsion :- >, <, == 


 Array of Pointer :- 
  int *ptr[variable] or int *ptr[10,20,30]
  ptr[i] = &var[i]
  *ptr[i] or ptr[i] 


 Pointer to Pointer :-
  - First pointer store address of second pointer and second pointer store address of variable
  Example :-
   int var = 30;
   int *ptr;
   int **pptr;
   ptr = &var
   pptr = &ptr  


 Passing Pointer to Function :-
  getSeconds(&sec);  // Declare function parameter as pointer type
  void getSeconds(unsigned long *par) {
    *par = time(NULL); 
   return;
  }

  //Function which accept pointer also accept array
  int balance[5] = {1000, 2, 3, 17, 50};
  getAverage(balance, 5);
   
  double getAverage(int *arr, int size) {
    int i, sum = 0;       
    double avg;           
    for(i = 0; i < size; ++i){sum += arr[i];}
    avg = (double)sum / size;
    return avg;
  }  

 
 Return Pointer from function in C :-
  int * myFunction() {
  }  



String :-
 - String are one-dimensional array of characters terminated by null character '\0'   
 Ex :- 
  char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
  printf("Greeting message: %s\n", greeting );

 Method :-
  strcpy(s1,s2) | strcat(s1,s2) | strlen(s1) | strcmp(s1,s2) 
  strchr(s1,ch) :- Return pointer to first occurrence of character ch in string s1
  strstr(s1,s2) :- Returns pointer to first occurrence of string s2 in string s1



Structure :-
 - Allow to combine data items of different kinds
 - Structure are used to represent record
 - To define structure struct keyword use
 - Structure tag is optional and each member definition is normal variable definition, such as int 
 - Before final semicolon, Specify one or more structure variables but it is optional
 

 Defining Structure :-
  struct [structure name] {
  member definition;
  member definition;
  } [one or more structure variables];  
 

 Example :-
  struct Books {
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
  } book;


 Accessing Structure :-
  - To access structure member use member access operator (.)
  struct Books Book1;
  strcpy( Book1.title, "C Programming");
  printf( "Book 1 title : %s\n", Book1.title);


 Structure as Function Argument :-
  - Pass structure as function argument is the same way pass any other variable or pointer
  void printBook( struct Books book ){
    printf( "Book title : %s\n", book.title);
  }


 Pointer to Structure :-
  struct Books *struct_pointer; 
  struct_pointer = &Book1;     // Store address of structure variable in above defined pointer variable
  struct_pointer->title;       // To access members of structure using pointer

  void printBook( struct Books *book ){
    printf( "Book title : %s\n", book->title) 
  }


 Bit Fields :- 
  - Allow packing of data in structure
  - Useful when memory or data storage is at premium
  struct packed_struct {
    unsigned int f1:1;
  }pack;



Union :-
 - Special data type that allow to store different data types in same memory location
 - Declare union with many member but only one member can contain value at given time 
 - Provide efficient way of using same memory location for multiple-purpose
 - Same memory location, used to store multiple types of data 
 
 Syntax :- 
  union [union tag] {
    member definition;
  }[one or more union variables];

 Example :-
  union Data {
    int i;
    float f;
    char str[20];
  } data;   
    
 Access :-  
  union Data data;        
  printf( "Memory size occupied by data : %d\n", sizeof(data));
  data.i = 10;
  printf( "data.i : %d\n", data.i);

 

Storage Classes :-
 - Define visibility(scope) and life-time of variable and function within Program
 Types :- auto, register, static, extern

 auto :- 
  - Default storage class for all variable
  Ex :- auto into st;
   
 register :- 
  - Declare local variables that stored in register instead of RAM for quick access
  - Variable maximum size equal to register size (Usually one word)
  - Can't applied unary '&' operator on it
  - It Does not mean that register variable stored in register it depend on hardware implementation
  Ex :- register int miles;

 static :-
  - Initialized only once and destroyed when program completed its execution
  - Compiler keep variables till the end of program
  - Default value is 0
  - When static used in global variable it one copy to be shared all objects of that class
  Ex :-  static int b = 8;

 extern :- Used to declare global variable or function in another file



Bit Field :-



typedef :-
 - Give data-type new name
 Syntax :- 
  typedef unsigned char BYTE;
  BYTE  b1, b2;  // BYTE used as abbreviation for type unsigned char
 
 typedef vs #define :-
  - #define is C-directive which used to define aliases for various data types similar to typedef but 
  - typedef is limited to giving symbolic names to types only where #define used to alias for all values as well
  - typedef interpretation performed by compiler where as #define statement are processed by pre-processor
 


File I/O :-
 - File represent sequence of bytes regardless of it being text file or binary file
 - C provide access on high level function as well as low level (OS level) call to handle file on storage device
  
 Opening file :-
  - fopen() create a new file or open existing file
  - It initialize FILE type object which contain all necessary information to control stream
  Syntax :- FILE *fopen(const char * filename, const char * mode);

  - filename is string literal which use to name file and access mode can have following
  Access mode :-
    r - Open existing file for reading 
    w - Open existing file for writing, if not existing create one 
    a - Open text file for writing in appending mode, if not existing create
    r+ - for both reading and writing
    w+ - for both reading and writing, first truncate file to zero length if exist otherwise create file 
    a+ - for both reading and writing, reading will start from beginning but writing only be appended
   
  For binary files :-
    rb, wb, r+b, ab, rb+, wb+, w+b, ab+, a+b


 Closing file :-    
  - To close file use fclose() function
  - fclose() return zero on success or EOF if there is an error in closing file
  - flushes data that still pending in buffer file, closes file and releases memory that used for file
  - EOF is constant defined in header file stdio.h
  Syntax :- int fclose( FILE *fp );

 
 Writing file :-
  - fputc() write character value of argument c to output stream referenced by fp 
  - It return written character on success otherwise EOF if there is error
  Syntax :- int fputc( int c, FILE *fp );
  
  - fputs() write string s to output stream referenced by fp 
  - It return non-negative value on success otherwise EOF returned in case of any error 
  
  - Use int fprintf(FILE *fp,const char *format, ...) function as well to write string into file
  
  Example :- 
    FILE *fp;
    fp = fopen("/tmp/test.txt", "w+");
    fprintf(fp, "This is testing for fprintf...\n");
    fputs("This is testing for fputs...\n", fp);
    fclose(fp);
  

 Reading File :-
  - fgetc() read character from input file referenced by fp 
  - return value is character read in case of any error it returns EOF
  - fgets() reads up to n-1 characters from input stream referenced by fp
  Syntax :- char *fgets( char *buf, int n, FILE *fp );

 
 Binary I/O :- 
  - size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); 
  - size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);



Pre-Processor :-
 - Not part of compiler but separate step in compilation process
 - It is just text substitution tool that instruct compiler to do required pre-processing before actual compilation
 - All preprocessor command begin with hash symbol (#)
  
 PreProcessor Description
  #define  - Substitute preprocessor macro
  #include - Insert particular header from another file
  #undef   - Undefine preprocessor macro
  #ifdef   - Return true if macro is defined
  #ifndef  - Return true if macro is not defined
  #if      - Test if compile time condition is true for
  #else    - alternative for #if
  #elif    - #else and #if in one statement
  #endif   - End preprocessor conditional
  #error   - Print error message on stderr
  #pragma  - Issue special command to compiler using standardized method
 
  Example :-
   #include <stdio.h>     // Add System Library
   #include "myheader.h"  // Add Local Library


 Predefined Macros :- ANSI C defines number of macros
  __DATE__ - Current date as character literal in "MMM DD YYYY" format
  __TIME__ - Current time as character literal in "HH:MM:SS" format
  __FILE__ - Contain current filename as string literal
  __LINE__ - Contain current line number as decimal constant
  __STDC__ - Defined as 1 when compiler complies with ANSI standard

  Example :- 
    printf("File :%s\n", __FILE__ );
    Output :- File :test.c


 Preprocessor Operators :-
  Macro Continuation (\) :- Confined single line, used to continue macro that is too long for single line
  Stringize (#)          :- Used within macro definition, convert macro parameter into string constant
  Token Pasting (##)     :- Combine two arguments, Permit two separate token in macro definition join intosingle token
  Defined()              :- Used in constant expression to determine if identifier is defined using #define



Header File :- 
 - File with .h extension contain C function declarations and macro definition shared between several source file
 Types  :- System files            |  User-defined files
 Syntax :- #include <System-file>  |  #include "User-file"



Error Handling :-
 - Not provide direct support for error handling but provide access at lower level in form of return value
 - Most of C or even Unix function call return -1 or NULL in case of any error and set an error code errno
 - Find various error codes defined in <error.h> header file
 - Value of 0 indicates that there is no error in program

 errno(), perror() and strerror()
  - perror() display string pass to it followed by colon, space and then textual representation of current errno value
  - strerror() return pointer to textual representation of current errno value
  - Use stderr file stream to output all error

 Program Exit Status :-
  - Exit program with value of EXIT_SUCCESS in case of program coming out after successful operation - 0
  - EXIT_FAILURE which defined as -1



Memory Management :-
 - Found in <stdlib.h>
 void *calloc(int num, int size); - Allocate array of num element each of size in bytes
 void free(void *address);        - Release block of memory block specified by address
 void *malloc(size_t size);       - Allocate array of num bytes and leave them uninitialized
 void *realloc(void *address, int newsize); - re-allocate memory extending it upto newsize

 Allocation Dynamically :-
  - If know size declare with :- char name[100]; / don't know :-  char *description;
  - use calloc(200, sizeof(char)); instead of malloc(200 * sizeof(char));

 Resizing and Releasing Memory :-
  - OS automatically release all memory allocate for program  
  - To release memory call free() 
  - Increase or decrease size of allocated memory block by calling realloc()