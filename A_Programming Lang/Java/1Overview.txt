Topics :-
 - Introduction(Basic / Feature / Intro JDK, JRE, JVM / DIFFERNCE BETWEEN JDK,JRE,JVM)
 - Variable
 - Literal
 - Identifier And Keyword
 - DataType
 - Operator
 - Expressions, Statements, Blocks and comment 
 - Control Flow(Condition / Switch / Loops /  Control Statement)
 - Array
 - File Handling
 - I/O Stream
 - Package
 - Data and Time
 - Regex



Introduction :-
 Basic :-
  - Developed by James Goshling at Sunmicrosystem and released in 1995 
  - Why JAVA not fully oop ? -> Support primitive datatype
  - Java Has no pointers and all code written in class and object
  - Pass non-primitve data-type always reference in function so that no bad memory allocation
  - James initialized java project in june 1991 for setTop box
  - Initially language called 'oak'(Tree outside) than 'Green' than 'Java' choose from random word
  - 13 November,2006 sun released much as free and open source software under GPL license



 Feature :-
  Object Oriented :- 
  Platform independent :- Java byte code interpreted by any machine which has jvm 
  Simple               :- Syntax is easy to learn and you master in oop it would be more easy language
  Secure               :- Built-in Feature that enables us to develop virus-free systems
  Architecture-Neural  :- Compiled code executable on many processor with java run time 
  Portable             :- Architecture-Neural and no implementation dependent makes java portable 
  Robust               :- Java eliminated error during compile time or runtime which maintains workflows 
  Multi-thread         :- Perform many task simultaneously , lightweight Process
  High-performance     :- Using Just-In-Time Compiler enables performance
  Dynamic              :- Carry runtime information that used to verify and resolve access to objects on runtime
  WORA(Write once run anywhere) 



 Naming Convention Rules :-
  class/interface :-Topcapital //First character is capital
  method 		 :- getRequest    //First character is small each internal word is capitalized
  constant	 :- MAX_VALUE     //All letters are uppercase 
  Variable   :- int a = 10;		//No whitespace,symbols and start with digit //Allow underscore and $ at start of variable 
  package    :- java.io.*;		//all package names in lowercase	



 Intro JDK, JRE, JVM :-
  What is JDK(Java Development Kit)?
   - JDK is software development kit required to develop applications in Java
 
  What is JVM(Java Virtual Machine)?
   - Acts as a runtime engine to run java application and call main method
   - When run Java program, Java compiler compile Java code to bytecode
   - Then JVM translates bytecode into native machine code(Set of instructions that computer's CPU executes directly)
   - Since JVM â€‹executes the Java bytecode which is platform-independent, Java is platform-independent
   - Part of JRE(Java Runtime Enviroment)

  What is JRE(Java Runtime Environment)?
   - JRE is software package that provide Java class libraries, JVM and other components that required to run Java code 
   - JRE is superset of JVM

  JDK = JRE + DEVELOPMENT TOOLS  (PLATFORM INDEPENDENT)
  JRE = JVM + LIBRARY CLASS 	(JVM PLATFORM DEPENDENT)
 
  Basic Jvm Working Cycle :-
    .java -> javac ->.class(same class name) with bytecode(run any machine) -> jvm -> machine code 
 
  
  Jvm Components Helps to Run Java :-
   JVM ClassLoader:- Responsible for Loading, Linking, Initalization

	  Loading :- Read .class file, generate corresponding binary data and save it in method area
    Linking :- Perform verification,preparation,and resolution(optionally)
	  Initalization :- Execute from top to bottom and all static variable are assigned with their values defined into code
    
			       			 req							req
	 System class loader ---> extension class loader --->bootstrap class loader --> If class found bootstrap path class loaded otherwise  
        |         														|
       	|	 extension move to system class loader ---<- <- Move Back to the extension class loader 
		(if system class loader fail load at starting)		path not found move to extension class
			|
		error : java.lang.ClassNotFoundException


   JVM MEMORY :-
    Methodarea  :- All class level information are stored like classname,variable,method etc 
    HeapArea    :- Information of all object is stored per jvm has one Heap area and it is a shared resource
    Stackarea   :- For every thread jvm create run-time stack which is stored hear
    PcRegister  :- Store current execution instruction of thread and each thrad have separate registers
    NativeMethodStack :- For every thread it's created that store thread native information
 

   EXECUTE ENGINE :-
    - Execute ".class"(bytecode) 
    - Read bytecode linebyline and use data and information present in various memory area and execute instrution
    Interpreter:- Interpretes bytecode line by line and executes 
    JIT(JUSTINTIME)  :- Compiles entire bytecode and convert into native code so whenever interpreter call method 
                        repeated jit provide direct native code for that part
    GarbageCollector :- It destroys un-referenced objects / free heap memory by destroying unreachable object 


   JAVA NATIVE INTERFACE (JNI):-
    - Interacts with native method libraries and provide native libraries(c/c++)required for execution 
    - Enable jvm to calls native libraries (c/c++)
 
   JVM STACK AREA :-
    - Every thread jvm create separate stack at the time of creation thread creation 
    - Perform 2 Operations :- pushes and pops the stack
    - Stack for particular thread may be termed as run-time stack
    - After all methods call stack empty and it becomes destroyed just before thread terminate
    - Each entry in the stack is called StackFrame or ActivationRecord

   JVM SHUTDOWNHOOK :-	
    - Special construct that allows developers to plug in piece of code to be executed when JVM is shutting down
    - Runtime.getRuntime().addShutdownHook(Thread) method

   JAVACLASS FILE :- Containing javabytecode and .classs extension that enable to run in jvm
    


 DIFFERNCE BETWEEN JDK,JRE,JVM :-
  JDK :- Used to create java application conatin jre, interpreter/loader, javac, archiver(jar), javadoc and other tool
  JRE :- JAVA RTE(RUNTIME ENVIROMENT) Provide minimum requirement for executing java application
  JVM :- Runtime instance when write java command on command prompt to run java class, an instance jvm is created

  DIFFERNCE :- 
  - Jdk provide develop and execute java program/ include development tool , jre 
  - JRE provide package to run program not develop 
  - JVM is inbuilt in both/when run program from jdk or jre jvm exectue line by line program known as interpreter

  HOW JRE WORKS :-
   .java -> .class    -> classloader/bytecode verifier -> interpreter -> runtime -> hardware	
	          \-/
		LOAD FROM HARDDISK,NETWORK OR OTHER RESOURCES
    compile       -> RUNTIME

  Interaction between jdk and jre :-
								/ JRE 
  javasourcecode -> jdk(java compiler) ->java bytecode -> ( jvm (jit) ) 
							(Hardware platform)



Variable :-
 - Variable is location in memory (storage area) to hold data
 - To indicate storage area, each variable should be given unique name (identifier)

 Declaration Rules :-
  - Start with letters, _ , $
  - Not start with number
  - Not allows whitespace and special Symbols

 Types :-
  Local Variables   - Declared inside method                     
  Parameters        - Declared in method parameter 
  Instance Variables (Non-Static Fields) - Declared inside class but outside method
  Class Variables (Static Fields)        - Declared inside class but outside method with static keyword

 Note :- 
  - Java is statically-typed language so all variables must be declared before they used
  - We cannot change data type of variable in Java within same scope

 Null :-
  - Null is not object or neither a type it is special value
  - Every reference variable in java has by default value is null / case-sensitive



Literal :-
 - Represents Fixed Value(Declare variables with values)

 Types :-
  Boolean - True or False
  Integer - Without any fractional part or exponation part(binary(0b),decimal(27),octal(027),Hexadecimal(0x27)) 
  Float   - float(3.4f) , double(3.3445e2)
  String  - Sequence of characters enclosed inside double-quotes("Java")
  Character - unicode character enclosed inside single quotes('a')Use :- escape sequences(\n,\b,\r,\t,\\,\',\'")
    


Identifier And Keyword :-
 - Identifiers are the name given to variables, classes, methods, etc..

 Rules :-
  - Case-sensitive and not be keyword
  - Start with letters, _ , $
  - Not start with number
  - Not allows whitespace and special Symbols

 Keyword :-
  - Keywords are predefined, reserved words used in Java programming that have special meanings for compiler

  Keywords List :-
  int   void    byte    char   boolean double  short  long   final     const    enum
  if    else    for     while   do      goto   return  break  continue  default
  try   catch	  assert  throw	 throws
  case  switch  this	
  class    new      static      private	  protected	  public
  import   package  implements  interface extends
  abstract finally	instanceof  strictfp	super       
  transient	synchronized  volatile  native



DataType :-
 - Specify type of data that can be stored inside variables in Java

 Primitive datatype :- 
  - Predefined by language and named by keyword 
  - Default value is 0

 DataType   Range of bytes         Sizebyte    Ex
  byte       -128 to 127                1     B1 = 100;   
  short      -32768 to 327676           2     B2 = 20; 
  int        -2,147,483,648 to 7        4     B3 = 20;
  float      6 to 7 decimal             4     B5 = 3.3f;
  double     15 decimal                 8     B6 = 7.44d;
  long       -9,223,372,036,854,775,808 to 7  B4 = 45;
  boolean    true or false              1bit  B7 = false;
  char                                  2     B8 = 'F';

 Non-Primitive type :- 
  - Reference variable that are created using constructors of the classes that Used to access object
  - Declared for specific type so value can't Change
  - Default value is null
  Ex :- String, Array, Class, Object

 Type Casting :-
  - Method or process that converts datatype into another datatype in both ways manually and automatically
  - Automatic conversion is done by the compiler and manual conversion performed by programmer

  Widening casting(automatically) :- Convert smaller type to larger type
   Ex :- byte -> short -> char -> int -> long -> float -> double 

  Narrowing casting(Manually) :- Convert larger type to smaller type
   Ex :- double -> float -> long -> int -> char -> short -> byte



Operator :-
 - Symbol that perform operations on variables and values
 Arithmatic :- + , - , * , / , %   
 Assignment :- = , += , -= , *= , /= , %= , &= , |= , ^= , >>= , <<=
 Realtional :- == , != , > , <  , >= , <=
 Logical    :- && , || , !
 Unary      :- -, +, ++ , -- , !(Logical Complement Operator):inverts the value of a boolean
 Ternary    :- Condition ? If(true) : If(false) 
 Bitwise    :- &, |, ^(XOR), ~(Complement Operator), << , >> , >>>(unsigned)
 New        :- New operator instantiates class dynamically by allocating at run time
 instanceOf :- Check type if object is instance of class, subclass or interface(result =str instanceof String)

 Operators Precedence :-
  Category	            Operator	                                            Associativity
    Postfix	            expression++ expression--	                            Left to right
    Unary	            ++expression â€“-expression +expression â€“expression ~ !	  Right to left
    Multiplicative	    * / %	                                                Left to right
    Additive	        + -	                                                    Left to right
    Shift	            << >> >>>	                                              Left to right
    Relational	        < > <= >= instanceof	                                Left to right
    Equality	        == !=	                                                  Left to right
    Bitwise AND	        &	                                                    Left to right
    Bitwise XOR	        ^	                                                    Left to right
    Bitwise OR	        |	                                                    Left to right
    Logical AND	        &&	                                                  Left to right
    Logical OR	        ||      	                                            Left to right
    Conditional	        ?:      	                                            Right to left
    Assignment	    = += -= *= /= %= ^= |= <<= >>= >>>=	                      Right to left



Input/Output :-
 Output :-
  - method to print data in java
  - System is a class 
  - out is public static field: accept user data 
  1)System.out.print()  - Print string inside quotes 
  2)System.out.println()- Same work like print but add new line in the end 
  3)System.out.printf() - Provides formatting same as c/c++ 

 Input :-
  - Get Input from user
  - Use Scanner class which we import from java.util.Scanner 
  Syntax :- Scanner usrInput = new Scanner(System.in);
  usrInput.nextInt(); - Take integer value from user 

 More Method :- 
  - nextFloat(), nextDouble(), nextLong, nextByte(), nextFloat()
  - next()Read input upto whitespace, does not read newline character in your input created by hitting "Enter"
  - nextLine()read line of text , returns after reading that newline
  - nextBigInteger, nextBigDecimal() requires import from java.math. package
  - System.in take standard input from user
  - Close() method to close object
  - Scanner class reads entire line and divides line into tokens which use for compiler to process input



Expressions, Statements, Blocks and comment :-

 Expressions :- Consist of variables, operators, literals and method calls
 Statements  :- Each statement is complete unit of execution
              - Convert expression into statement by terminating expression with a " ; "  Known as expression statement
              Ex :- int score = 9*5;
 Blocks  :- Block is group of statements (zero or more) that is enclosed in curly braces { }
 Comment :- Portion of program that are completely ignored by Java compilers 
          - Helps progrmmers to understand code
          Type :- Single line :- //     |   Multi-Line  :- /* */



Control Flow :- 
 Condition :-
  If         :- if(condtion){}
  If..Else.. :- if(condtion){}else{}
  Else-if    :- if(condtion1){}else if(condtion2){}else{}
  Ternary    :- var = (condition) ? expressionTrue : expressionFalse;
 
 Switch :-
  - Expression evaluated once then compared with values of each case statement
  - If match, associated block of code is executed otherwise default block executed
  - No duplicate case statement allowed
  Syntax :- 
    switch(expression)  
    {
      case n:
      //code block
      break;
    
      default:
      //code block
    }

 Loops :- Execute block of code as long as condition is true, to save time, reduce errors, make code readable   
  for       :- for (initialization ; condition ; increment/decrement){ //code } 
  while     :- while(condition){ //code }
  do..while :- do{ //code }while(condition)
  foreach   :- for(type variableName : arrayName){ //code }

 Control Statement :- 
  break  :- Terminates loop immediately and control of program moves to next statement 
          - Use label break statement to terminate outermost loop as well Ex :- break second: (This is label use)
  continue :- Skip current iteration of loop and go next iteration
  Note :- Java not support goto but use  " label: " instead of goto
        - Label declare starting point of the loop 



Array :- 
 - Array is collection of similar types of 
 - Contain same data-type group of element
 - Array are dynamically allocated, Ordered and start index with 0
 - In primitive type actual values are stored in contiguous memory locations
 - In objects of class actual object are stored in heap segment
 - To access element of outside array size JVM throws ArrayIndexOutOfBoundsException
 - Superclass of any array type is java.lang.Object
 - Default value of primitive datatype is 0 and user-defined type is null

 Syntax :- 
   data-type[] variablename;                     //declared  only reference of array is created
   Variablename = new datatype[arraysize];       //create a new array give memory location

   dataType[] arrayRefVar = new dataType[arraySize];     //In one line create a new array 
   String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};    //create a new array with value Declaring array literal

   Access Elements :- arrayRefVar[indexNo]; Or Loops
   Update Elements :- arrayRefVar[indexNo] = new value; 
   Find Length     :- arrayRefVar.length;          
         
 Syntax :- Multi-dimensional array containing one or more array
    int[][] intArray = new int[10][20];         //2D array or matrix
    int[][][] intArray = new int[10][20][10];   //3D array


 Class objects of arrays :-
  - Every array has associated Class object that shared with all other arrays with same component type
  Syntax :- arrayVariable.getClass()  / arrayVariable.getclass().getSuperclass()

 
 Array Class :-
  - Deriverd from java.util package part of Java Collection Framework
  - Provide static method to dynamically create and access Java array
  - It consists of only static method and method of Object class
  - Method of this class can be used by class name itself
  Hierachiy :- java.lang.Object -> java.util.Arrays
  - java.util.Arrays class contains various static methods for sorting and searching, comparing ,filling array element

 Reflection Array Class :- 
  - java.lang.reflect provide static method to dynamically create and access Java array
  - It is final class which means it canâ€™t be instantiated or changed
  - Only method of this class can be used by class name itself

 Final Array :-
  - Array variable which actually reference to object cannot be changed to refer to anything else,
    but member of array can be modified
 
 Jagged Array :-
   - Jagged array is array of arrays such that member array can be of different sizes

 
 Exception :-
  Checked   :- Checked at compile time
  Unchecked :- Unchecked at compile time
   - In Java exceptions under Error and RuntimeException classes are unchecked exceptions, everything else under 
     throwable is checked



FileHandling :-
 - java.io.file package use
 Syntax :-  File a = new File(filename/pathforfile);

 Constructors :-
  File(File parent, String child)   
  File(String pathname)           
  File(String parent, String child) 
  File(URI uri)

 Method :-
  boolean canExecute()           : Test application execute file denoted by this abstract pathname
  boolean canRead()              : Test application read file denoted by this abstract pathname
  boolean canWrite()             : Test whether application modify file denoted by this abstract pathname
  int compareTo(File pathname)   : Compare two abstract pathnames lexicographically
  boolean createNewFile()        : Automatically creates new empty file named by this abstract pathname 
  static File createTempFile()   : Create empty file in default temporary-file directory
  boolean delete()               : Delete file or directory denoted by this abstract pathname
  boolean equals(Object obj)     : Test abstract pathname for equality with given object
  boolean exists()               : Test whether file or directory denoted by this abstract pathname exists
  String getAbsolutePath()       : Return absolute pathname string of this abstract pathname
  long getFreeSpace()            : Return number of unallocated bytes in the partition
  String getName()               : Return name of file or directory denoted by this abstract pathname
  String getParent()             : Return pathname string of this abstract pathnameâ€™s parent
  File getParentFile()           : Return pathname of this abstract pathnameâ€™s parent
  String getPath()               : Convert pathname into a pathname string
  boolean isDirectory()          : Test file denoted by this pathname is a directory
  boolean isFile()               : Test file denoted by this abstract pathname is a normal file
  boolean isHidden()             : Test file named by this abstract pathname is a hidden file
  long length()                  : Return length of file denoted by this abstract pathname
  String[] list()                : Return array of string naming files and directories in directory
  File[] listFiles()             : Return array of abstract pathname denoting files in directory
  boolean mkdir()                : Create directory named by this abstract pathname
  boolean renameTo(File dest)    : Rename file denoted by this abstract pathname
  boolean setExecutable()        : Set execute permission
  boolean setReadable()          : Set read permission
  boolean setReadable()          : Set everybodyâ€™s read permission
  boolean setReadOnly()          : Mark file or directory named so that only read operations are allowed
  boolean setWritable()          : Convenience method to set ownerâ€™s write permission
  String toString()              : Return pathname string of this abstract pathname
  URI toURI()                    : Construct file URI that represent this abstract pathname



I/O Stream :-
 - Stream is method to sequentially access file
 - java.io package use for character stream unicode and binary stream non-unicode text
 
 Type :-
  InPutStream  âˆ’ Used to read data from source
  OutPutStream âˆ’ Used for writing data to destination

 Character Stream :-
  - Character are stored using unicode characters
  - Allow read/write data characters by character automatically
  - Perform input and output for 16-bit unicode
  Ex :- FileReader and FileWriter 

 Byte Stream :-
  - Process data bytes by byte sequence(8bit)
  Ex :- FileInputStream and FileOutputStream

 When to use Character Stream over Byte Stream? 
  - Character stream is useful to process text files
  - ByteStream suitable for processing raw data like binary files
 
 Standard Stream :-
  Standard Input  :- System.in
  Standard Output :- System.out
  Standard Error  :- System.err

 Hierachy Of Stream :-
                 Object
    InputStream         OutputStream 
    File                - Same in outputStream
    ByteArrayInput
    FilterInputStream
     -BufferedInput
     -DataInputStream  
    ObjectInputStream



Pacakge :-
 - Used to group related classes
 - Avoid name conflict and write better maintainable code

 1)Built-in package       (Package from java api)
 2)User defined package   (Create own package)

 Built-in package :-
  - Java api is library of prewritten classes
  - library divided into two part :- package and classes
  - Either import single class or import whole package that contain all classes
  Ex :- import package.name.class; single class 
        import package.name.*;     import whole package  

 User defined package :-
  - Java uses file system directory to store them
  - root ->mypack -> filename.java    



Date And Time :-
 - Not have built-in date class but import java.time package to work with data and time api
 - java.util package, this class encapsulates current date and time

 Constructor :-
  Date()  :- Initalize date and Time Object
  Date(long milliseconds) :- Accept argument that equals number of milliseconds

 Calender :-
  - Calendar Class being an abstract class cannot be instantiated
  - So an object of the Calendar Class is initialized as: 
  Syntax :- Calendar cal = Calendar.getInstance();
  - Use java.util.GregorianCalendar and java.util.Calendar
  - Object of Calendar Class is initialized with current date and time in the default locale and timezone
  - Whereas, GregorianCalendar Class being concrete class, can be instantiated
  - So object of GregorianCalendar Class is initialized as: 
    Syntax :- GregorianCalendar gcal = new GregorianCalendar();
  - gcal of GregorianCalendar Class is initialized with current date and time in default locale and timezone



Regular Expression :-
 - Special sequence of characters that helps to match or find other strings or sets of string, Using specialized 
   syntax held in pattern
 - java.util.regex package used

 Pattern Class :-
  - To create pattern first invoke one of its public static compile() method, which will then return Pattern object
  - Method accept regular expression as first argument

 Matcher Class :âˆ’    
  - Matcher object is the engine that interprets pattern and performs match operations against input string
  - Matcher defines no public constructors
  - Obtain Matcher object by invoking matcher() method on Pattern object

 PatternSyntaxException :âˆ’ 
  - PatternSyntaxException object is unchecked exception that indicates syntax error in regular expression pattern

 Capturing Group :-
  - Way to treat multiple characters as a single unit
  - To find out how many groups are present in expression, call groupCount method on matcher object

 Common use Symbols :-
    ^	    Match beginning of line
    $	    Match end of line
    .	    Match single character except newline, Using m option allows it to match newline as well
    [...]	Match any single character in brackets
    [^...]	Match any single character not in brackets
    \A	    Beginning of entire string
    \z	    End of entire string
    a| b	Match either a or b
    \W	    Match nonword characters
    \w	    Match word characters
    \s	    Match whitespace, Equivalent to [\t\n\r\f]
    \S	    Match nonwhitespace
    \d	    Match digits. Equivalent to [0-9].
    \D	    Match nondigits


 Method :-
  Start   :- Return start index of previous match
  End     :- Return offset after last character matched
  find    :- Attempt to find next subsequence of input sequence that matches pattern
  matches :- Attempt to match entire region against pattern
  lookingAt :- match input sequence starting at beginning of the region against pattern

 Replacements Methods :-
  replaceAll         :- Replace every subsequence of input sequence
  replaceFirst       :- Replace first subsequence of input sequence
  quoteReplacement   :- Return literal of replacement string or specified string
  Matcher appendReplacement :- Implement non-terminal append-and-replace step
  StringBuffer appendTail   :- terminal

 PatternSyntaxException Class Methods :-
  getIndex       :- Return error index
  getPattern     :- Retrieve erroneous regular expression pattern
  getMessage     :- Return multi-line string containing error
  getDescription :- Return description error message

