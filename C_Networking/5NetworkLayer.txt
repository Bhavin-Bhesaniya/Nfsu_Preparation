Introduction to Network Layer(Layer-3) :-
  - Translates logical addresses into physical addresses
  - It determine route from source to destination and also manage traffic problem such as switching, routing and 
    control congestion of data packet
  - Move packet from sending host to receiving host
  
  Function :-
   Routing :- Move packet from Sending host router's input link to another router's output link 
   Internetworking :- It provide logical connection between different types of networks
   Fragmentation   :- Breaking packet into smallest individual data unit that travel through different network
   Logical Addressing :- 
    - Used to Distinguish between source and destination system 
    - Add header to packet which include logical addresses of both sender and receiver

   Forwarding & Routing :- 
    - Every router has forwarding table 
    - Router forward packet by examining packet's header field then using it value to index into forwarding table 
    - Value store in forwarding table corresponding to header field value indicate router's outgoing interface link
      to which packet is to be forwarded
    - Routing algorithm can be centralized or decentralized

    Diagram :- Forwarding Table
     HeaderValue  OutputLink
        0100        3
        0101        2
        0100        2
        1111        1


  Services :- 
   Guaranteed delivery :- Guarantees that packet arrive at its destination
   Guaranteed delivery with bounded delay :- Packet delivered within specified host-to-host delay bound
   In-Order packets      : Packet arrives at destination in the order in which they are sent
   Guaranteed max jitter : 
    - Amount of time taken between two successive transmission at sender is equal to time taken receipt at destination
   
   Security services : 
    - Security using session key between source and destination host 
    - Source host encrypt payloads of data being sent to destination host 
    - Destination host would then decrypt payload 
    - Maintain data integrity and source authentication service



Network Addressing :-
 - Network addresses are always logical, i.e., software-based addresses.
 - Host is also known as end system that has one link to network 
 - Boundary between host and link is known as interface Therefore host have only one interface
 - Router is different from host in that it has two or more links that connect to it 
 - When router forward datagram then it forward packet to one of the links 
 - Boundary between router and link is known as interface and router have multiple interface one for each of its link 
 - Each interface capable of sending and receiving IP packet so IP requires each interface have an address
 - Each IP address 32 bits long and represented in form of "dot-decimal notation" where each byte written in decimal 
   form separated by period 
 - IP address would look like 193.32.216.9 where 193 represent decimal notation of first 8 bits of an address, 
   32 represent second 8 bit address
 - First three bytes in IP address specifies network and last byte of IP address specifies host in network


 Classful Addressing :-
  IP address is divided into sub-classes : Class A  |  Class B  |  Class C  |  Class D  |  Class E
  Ip address is divided into two parts :- Network ID : Represent number of network | Host ID : Represent number of host

  Diagram :- 
                Byte-1      Byte-2      Byte-3      Byte-4     (8-bit)
    Class A     NET ID      <---------- Host ID ---------->  
    Class B     <---- NET ID ---->      <---- Host ID ---->
    Class C     <---------- NET ID ---------->      Host ID  
    Class D     <----------- MultiCast Address ----------->
    Class E     <---------------- RESERVED --------------->


  Class A :-
    - IP address assigned to those network that contain large number of hosts
    - NET ID is 8 bit and host ID is 24 bits long
    - First bit in higher order bits of first octet is always set to 0 and remaining 7 bits determine network ID 
    - 24 bit determine host ID in any network
    - Total number of network in Class A = 2^7 = 128 network address
    - Total number of hosts in   Class A = 2^24 - 2 = 16,777,214 host address

                       7 bit      24 bit
    Diagram :- | 0 |  NET ID  |  Host ID | 

  
  Class B :-
   - IP address assigned to those network that range from small-sized to large-sized network
   - NET ID is 16 bit and host ID is 16 bits long
   - Higher order bit of first octet is always set to 0,1 and remaining 14 bits determine network ID and 16 bit Host ID
   - Total number of network in Class A = 2^14 = 16384 network address
   - Total number of hosts in   Class A = 2^16 - 2 = 65534 host address
                          14 bit      16 bit
    Diagram :- | 0 | 1 |  NET ID  |  Host ID  | 


  Class B :-
   - IP address is assigned to only small-sized networks
   - NET ID is 24 bit and host ID is 8 bits long
   - Higher order bit of first octet is always set to 1,1,0 and remaining 21 bit determine network ID and 8 bit Host ID
   - Total number of network in Class A = 2^21 = 2097152 network address
   - Total number of hosts in   Class A = 2^8 - 2 = 254 host address
                          14 bit      16 bit
    Diagram :- | 1 | 1 | 0 |  NET ID  |  Host ID  | 
      
 
  Class D :-
   - IP address reserved for multicast addresses and not possess subnetting 
   - Higher order bits of first octet is always set to 1110 and remaining bits determine host ID in network.
                                   28 bit
    Diagram :- | 1 | 1 | 1 | 0 |  Host ID  |  


  Class E :-
   - IP address used for future use or for research and development purposes 
   - Does not possess any subnetting 
   - Higher order bits of first octet always set to 1111 and remaining bits determine host ID in network
                                  28 bit
    Diagram :- | 1 | 1 | 1 | 0 |  Host ID  |


  Rules for assigning Host ID :
   - Used to determine host within any network 
   - Host ID must be unique 
   - All bits are set to 0 cannot be assigned as it represent network ID of IP address
   - All bits are set to 1 cannot be assigned as it is reserved for multicast address


  Rules for assigning Network ID :
   - If host located within same local network then they assigned with same network ID 
   - Cannot start with 127 as 127 is used by Class A
   - All bit set to 0 cannot be assigned as it specify particular host on local network
   - All bits set to 1 cannot be assigned as it is reserved for multicast address
  
  
  Classful Network Architecture
   Class  Higher bits	     NET ID bits	HOST ID bits   No.of networks	No.of hosts per network	Range
     A	  0	        8	        24	            27	         2^24	        0.0.0.0 to 127.255.255.255
     B	  10	    16	        16	            214	         2^16	        128.0.0.0 to 191.255.255.255
     C	  110	    24	        8	            221	         2^8	        192.0.0.0 to 223.255.255.255
     D	  1110	Not Defined	 Not Defined	Not Defined	  Not Defined	    224.0.0.0 to 239.255.255.255
     E	  1111	Not Defined	 Not Defined	Not Defined	  Not Defined	    240.0.0.0 to 255.255.255.255



Routing :-
 - Process of selecting path for data transferred which performed by pecial device known as router
 - Router work at network layer in OSI model and internet layer in TCP/IP model
 - Router forward packet based on information in packet header and forwarding table
 - Routing algorithm nothing but software responsible for deciding optimal path for packet transfer
 - Routing protocols use metric to determine best path for packet delivery 
 
 Routing Metrics and Costs :-
  - Determining best route to destination 
  - Metric is network variable standard measurement such as hop count, bandwidth, delay, current load on path etc
    it used by routing algorithm to determine optimal path to destination
  - Some routing protocols use dynamic metrics means that their value assigned by system administrator

  Common metric values :-
   Hop count :- 
    - Specifies number of passes through internetworking devices such as router, packet must travel in route to move
    - If protocol consider hop as primary metric value then path with least hop count considered as best path to move
   
   Delay :- 
    - Time taken by router to process, queue and transmit datagram to interface 
    - Protocol use to determine delay values for all links along path end-to-end 
    - Path having lowest delay value will considered as best path
   
   Bandwidth :- 
    - Capacity of link is known as bandwidth of link 
    - It Measured in terms of bits per second
    - Link that has higher transfer rate like gigabit is preferred over lower capacity like 56 kb 
    - Protocol determine bandwidth capacity for all links along path and overall higher bandwidth considered best route

   Load :- 
    - Degree to which network resource such as router or network link is busy 
    - Calculated in such as CPU utilization, packets processed per second 
    - If traffic increases then load value also increased and changes with respect to change in traffic

   Reliability :- 
    - Composed of a fixed value that depend on network links and its value is measured dynamically 
    - Some networks go down more often than others
    - After network failure some network links repaired more easily than other network links 
    - Factor for Reliability that numeric values assigned by system administrator


 Types of Routing :- Static Routing | Default Routing | Dynamic Routing

  Static Routing (Nonadaptive Routing) :-
   - Administrator manually add routes in routing table and router send packet based on table
   - Routing decisions not made by condition or topology of networks
   
   Advantages    :- No Overhead(Cpu usage) | Not Bandwidth | Security Administrator 
   Disadvantages :- Very difficult for large network | Administrator good knowledge of topology required 

  Default Routing :-
   - Router is configured to send all packets to same hop device and it doesn't matter whether it belongs to particular
     network or not
   - Used when network deal with single exit point
   - Useful when bulk of transmission network transmit data to same device
   - When specific route mentioned in routing table router will choose specific route rather than default route
   - Default route is chosen only when specific route is not mentioned in routing table

  
  Dynamic Routing(Adaptive Routing):-
   - Router adds new route in routing table for each packet in response to changes in condition or topology of network
   - Dynamic protocol used to discover new routes to reach destination
   - RIP and OSPF protocol used to discover new routes
   - If any route goes down then automatic adjustment made to reach destination

   Features :- 
    - All router must have same dynamic routing protocol in order to exchange routes
    - If router discover any change in the condition of topology then router broadcast information to all other router
   
   Advantages    :- Easier to configure | More effective in selecting best route
   Disadvantages :- More expensive in terms of CPU and bandwidth usage | Less secure 
   






Network Layer Protocols :-
 
 ARP(Address Resolution Protocol) :-
  - Associate IP address with MAC address
  - Each device on network recognized by MAC address imprinted on NIC 
  - MAC address can be changed easily but IP address does not change 
  - ARP used to find MAC address of node when internet address is known
  Note :-  
   MAC address : Used to identify actual device 
   IP address  : Address used to locate device on network

  
  How ARP works :-
   - If host wants to know physical address of another host on its network then it send ARP query packet(ARP cache) 
     that include IP address or not otherwise broadcast it over network 
   - Every host on network receives and processes ARP packet but only intended recipient recognizes IP address and send
     response back physical address
   - Host holding datagram add physical address to cache memory and to datagram header then sends back to sender
   - Once MAC address received by device then communication take place between two device
   Note: ARP cache is used to make a network more efficient.

  
  Types of ARP entries :
   Dynamic entry :- Automatically created when sender broadcast its message to entire network (not permanent and remove)
   Static entry  :- Where someone manually enter IP to MAC address association by using ARP command utility.


 RARP(Reverse Address Resolution Protocol) :-
  - Obtain IP address from server
  - Host need IP address then broadcast RARP query packet that contain its physical address to entire network
  - RARP server on network recognizes RARP packet and respond back with host IP address
  - Message format similar to ARP protocol
  - Like ARP frame, RARP frame is sent from one machine to another in encapsulated data


 ICMP(Internet Control Message Protocol) :-
  - Used by host and router to send notification of IP datagram problem back to sender
  - ICMP uses echo test/reply to check whether the destination is reachable and responding.
ICMP handles both control and error messages, but its main function is to report the error but not to correct them.
An IP datagram contains the addresses of both source and destination, but it does not know the address of the previous router through which it has been passed. Due to this reason, ICMP can only send the messages to the source, but not to the immediate routers.
ICMP protocol communicates the error messages to the sender. ICMP messages cause the errors to be returned back to the user processes.
ICMP messages are transmitted within IP datagram.
Network Layer Protocols
The Format of an ICMP message
Network Layer Protocols
The first field specifies the type of the message.
The second field specifies the reason for a particular message type.
The checksum field covers the entire ICMP message.
Error Reporting
ICMP protocol reports the error messages to the sender.

Five types of errors are handled by the ICMP protocol:

Destination unreachable
Source Quench
Time Exceeded
Parameter problems
Redirection
Network Layer Protocols
Destination unreachable: The message of "Destination Unreachable" is sent from receiver to the sender when destination cannot be reached, or packet is discarded when the destination is not reachable.
Source Quench: The purpose of the source quench message is congestion control. The message sent from the congested router to the source host to reduce the transmission rate. ICMP will take the IP of the discarded packet and then add the source quench message to the IP datagram to inform the source host to reduce its transmission rate. The source host will reduce the transmission rate so that the router will be free from congestion.
Time Exceeded: Time Exceeded is also known as "Time-To-Live". It is a parameter that defines how long a packet should live before it would be discarded.
There are two ways when Time Exceeded message can be generated:

Sometimes packet discarded due to some bad routing implementation, and this causes the looping issue and network congestion. Due to the looping issue, the value of TTL keeps on decrementing, and when it reaches zero, the router discards the datagram. However, when the datagram is discarded by the router, the time exceeded message will be sent by the router to the source host.

When destination host does not receive all the fragments in a certain time limit, then the received fragments are also discarded, and the destination host sends time Exceeded message to the source host.

Parameter problems: When a router or host discovers any missing value in the IP datagram, the router discards the datagram, and the "parameter problem" message is sent back to the source host.
Redirection: Redirection message is generated when host consists of a small routing table. When the host consists of a limited number of entries due to which it sends the datagram to a wrong router. The router that receives a datagram will forward a datagram to a correct router and also sends the "Redirection message" to the host to update its routing table.


IGMP(Internet Group Message Protocol) :-
The IP protocol supports two types of communication:
Unicasting: It is a communication between one sender and one receiver. Therefore, we can say that it is one-to-one communication.
Multicasting: Sometimes the sender wants to send the same message to a large number of receivers simultaneously. This process is known as multicasting which has one-to-many communication.
The IGMP protocol is used by the hosts and router to support multicasting.
The IGMP protocol is used by the hosts and router to identify the hosts in a LAN that are the members of a group.
Network Layer Protocols
IGMP is a part of the IP layer, and IGMP has a fixed-size message.
The IGMP message is encapsulated within an IP datagram.
Network Layer Protocols
The Format of IGMP message
Network Layer Protocols
Where,

Type: It determines the type of IGMP message. There are three types of IGMP message: Membership Query, Membership Report and Leave Report.

Maximum Response Time: This field is used only by the Membership Query message. It determines the maximum time the host can send the Membership Report message in response to the Membership Query message.

Checksum: It determines the entire payload of the IP datagram in which IGMP message is encapsulated.

Group Address: The behavior of this field depends on the type of the message sent.

For Membership Query, the group address is set to zero for General Query and set to multicast group address for a specific query.
For Membership Report, the group address is set to the multicast group address.
For Leave Group, it is set to the multicast group address.
IGMP Messages
Network Layer Protocols
Membership Query message
This message is sent by a router to all hosts on a local area network to determine the set of all the multicast groups that have been joined by the host.
It also determines whether a specific multicast group has been joined by the hosts on a attached interface.
The group address in the query is zero since the router expects one response from a host for every group that contains one or more members on that host.
Membership Report message
The host responds to the membership query message with a membership report message.
Membership report messages can also be generated by the host when a host wants to join the multicast group without waiting for a membership query message from the router.
Membership report messages are received by a router as well as all the hosts on an attached interface.
Each membership report message includes the multicast address of a single group that the host wants to join.
IGMP protocol does not care which host has joined the group or how many hosts are present in a single group. It only cares whether one or more attached hosts belong to a single multicast group.
The membership Query message sent by a router also includes a "Maximum Response time". After receiving a membership query message and before sending the membership report message, the host waits for the random amount of time from 0 to the maximum response time. If a host observes that some other attached host has sent the "Maximum Report message", then it discards its "Maximum Report message" as it knows that the attached router already knows that one or more hosts have joined a single multicast group. This process is known as feedback suppression. It provides the performance optimization, thus avoiding the unnecessary transmission of a "Membership Report message".
Leave Report
When the host does not send the "Membership Report message", it means that the host has left the group. The host knows that there are no members in the group, so even when it receives the next query, it would not report the group.




Routing algorithm
In order to transfer the packets from source to the destination, the network layer must determine the best route through which packets can be transmitted.
Whether the network layer provides datagram service or virtual circuit service, the main job of the network layer is to provide the best route. The routing protocol provides this job.
The routing protocol is a routing algorithm that provides the best path from the source to the destination. The best path is the path that has the "least-cost path" from source to the destination.
Routing is the process of forwarding the packets from source to the destination but the best route to send the packets is determined by the routing algorithm.
Classification of a Routing algorithm
The Routing algorithm is divided into two categories:

Adaptive Routing algorithm
Non-adaptive Routing algorithm
Routing algorithm
Adaptive Routing algorithm
An adaptive routing algorithm is also known as dynamic routing algorithm.
This algorithm makes the routing decisions based on the topology and network traffic.
The main parameters related to this algorithm are hop count, distance and estimated transit time.
An adaptive routing algorithm can be classified into three parts:

Centralized algorithm: It is also known as global routing algorithm as it computes the least-cost path between source and destination by using complete and global knowledge about the network. This algorithm takes the connectivity between the nodes and link cost as input, and this information is obtained before actually performing any calculation. Link state algorithm is referred to as a centralized algorithm since it is aware of the cost of each link in the network.
Isolation algorithm: It is an algorithm that obtains the routing information by using local information rather than gathering information from other nodes.
Distributed algorithm: It is also known as decentralized algorithm as it computes the least-cost path between source and destination in an iterative and distributed manner. In the decentralized algorithm, no node has the knowledge about the cost of all the network links. In the beginning, a node contains the information only about its own directly attached links and through an iterative process of calculation computes the least-cost path to the destination. A Distance vector algorithm is a decentralized algorithm as it never knows the complete path from source to the destination, instead it knows the direction through which the packet is to be forwarded along with the least cost path.
Non-Adaptive Routing algorithm
Non Adaptive routing algorithm is also known as a static routing algorithm.
When booting up the network, the routing information stores to the routers.
Non Adaptive routing algorithms do not take the routing decision based on the network topology or network traffic.
The Non-Adaptive Routing algorithm is of two types:

Flooding: In case of flooding, every incoming packet is sent to all the outgoing links except the one from it has been reached. The disadvantage of flooding is that node may contain several copies of a particular packet.

Random walks: In case of random walks, a packet sent by the node to one of its neighbors randomly. An advantage of using random walks is that it uses the alternative routes very efficiently.

Differences b/w Adaptive and Non-Adaptive Routing Algorithm
Basis Of Comparison	Adaptive Routing algorithm	Non-Adaptive Routing algorithm
Define	Adaptive Routing algorithm is an algorithm that constructs the routing table based on the network conditions.	The Non-Adaptive Routing algorithm is an algorithm that constructs the static table to determine which node to send the packet.
Usage	Adaptive routing algorithm is used by dynamic routing.	The Non-Adaptive Routing algorithm is used by static routing.
Routing decision	Routing decisions are made based on topology and network traffic.	Routing decisions are the static tables.
Categorization	The types of adaptive routing algorithm, are Centralized, isolation and distributed algorithm.	The types of Non Adaptive routing algorithm are flooding and random walks.
Complexity	Adaptive Routing algorithms are more complex.	Non-Adaptive Routing algorithms are simple.




Distance Vector Routing Algorithm
The Distance vector algorithm is iterative, asynchronous and distributed.
Distributed: It is distributed in that each node receives information from one or more of its directly attached neighbors, performs calculation and then distributes the result back to its neighbors.
Iterative: It is iterative in that its process continues until no more information is available to be exchanged between neighbors.
Asynchronous: It does not require that all of its nodes operate in the lock step with each other.
The Distance vector algorithm is a dynamic algorithm.
It is mainly used in ARPANET, and RIP.
Each router maintains a distance table known as Vector.
Three Keys to understand the working of Distance Vector Routing Algorithm:
Knowledge about the whole network: Each router shares its knowledge through the entire network. The Router sends its collected knowledge about the network to its neighbors.
Routing only to neighbors: The router sends its knowledge about the network to only those routers which have direct links. The router sends whatever it has about the network through the ports. The information is received by the router and uses the information to update its own routing table.
Information sharing at regular intervals: Within 30 seconds, the router sends the information to the neighboring routers.
Distance Vector Routing Algorithm
Let dx(y) be the cost of the least-cost path from node x to node y. The least costs are related by Bellman-Ford equation,

dx(y) = minv{c(x,v) + dv(y)}
Where the minv is the equation taken for all x neighbors. After traveling from x to v, if we consider the least-cost path from v to y, the path cost will be c(x,v)+dv(y). The least cost from x to y is the minimum of c(x,v)+dv(y) taken over all neighbors.

With the Distance Vector Routing algorithm, the node x contains the following routing information:

For each neighbor v, the cost c(x,v) is the path cost from x to directly attached neighbor, v.
The distance vector x, i.e., Dx = [ Dx(y) : y in N ], containing its cost to all destinations, y, in N.
The distance vector of each of its neighbors, i.e., Dv = [ Dv(y) : y in N ] for each neighbor v of x.
Distance vector routing is an asynchronous algorithm in which node x sends the copy of its distance vector to all its neighbors. When node x receives the new distance vector from one of its neighboring vector, v, it saves the distance vector of v and uses the Bellman-Ford equation to update its own distance vector. The equation is given below:

dx(y) = minv{ c(x,v) + dv(y)}     for each node y in N
The node x has updated its own distance vector table by using the above equation and sends its updated table to all its neighbors so that they can update their own distance vectors.

Algorithm
At each node x,
Initialization


for all destinations y in N:
Dx(y) = c(x,y)     // If y is not a neighbor then c(x,y) = ∞
for each neighbor w
Dw(y) = ?     for all destination y in N.
for each neighbor w
send distance vector Dx = [ Dx(y)  : y in N ] to w
loop
  wait(until I receive any distance vector from some neighbor w)
  for each y in N:
  Dx(y) = minv{c(x,v)+Dv(y)}
If Dx(y) is changed for any destination y
Send distance vector Dx = [ Dx(y) : y in N ] to all neighbors
forever
Note: In Distance vector algorithm, node x update its table when it either see any cost change in one directly linked nodes or receives any vector update from some neighbor.
Let's understand through an example:

Sharing Information
Distance Vector Routing Algorithm
In the above figure, each cloud represents the network, and the number inside the cloud represents the network ID.
All the LANs are connected by routers, and they are represented in boxes labeled as A, B, C, D, E, F.
Distance vector routing algorithm simplifies the routing process by assuming the cost of every link is one unit. Therefore, the efficiency of transmission can be measured by the number of links to reach the destination.
In Distance vector routing, the cost is based on hop count.
Distance Vector Routing Algorithm
In the above figure, we observe that the router sends the knowledge to the immediate neighbors. The neighbors add this knowledge to their own knowledge and sends the updated table to their own neighbors. In this way, routers get its own information plus the new information about the neighbors.

Routing Table
Two process occurs:

Creating the Table
Updating the Table
Creating the Table
Initially, the routing table is created for each router that contains atleast three types of information such as Network ID, the cost and the next hop.

Distance Vector Routing Algorithm
NET ID: The Network ID defines the final destination of the packet.
Cost: The cost is the number of hops that packet must take to get there.
Next hop: It is the router to which the packet must be delivered.
Distance Vector Routing Algorithm
In the above figure, the original routing tables are shown of all the routers. In a routing table, the first column represents the network ID, the second column represents the cost of the link, and the third column is empty.
These routing tables are sent to all the neighbors.
For Example:

A sends its routing table to B, F & E.  
B sends its routing table to A & C.  
C sends its routing table to B & D.  
D sends its routing table to E & C.  
E sends its routing table to A & D.  
F sends its routing table to A.  
Updating the Table
When A receives a routing table from B, then it uses its information to update the table.
The routing table of B shows how the packets can move to the networks 1 and 4.
The B is a neighbor to the A router, the packets from A to B can reach in one hop. So, 1 is added to all the costs given in the B's table and the sum will be the cost to reach a particular network.
Distance Vector Routing Algorithm
After adjustment, A then combines this table with its own table to create a combined table.
Distance Vector Routing Algorithm
The combined table may contain some duplicate data. In the above figure, the combined table of router A contains the duplicate data, so it keeps only those data which has the lowest cost. For example, A can send the data to network 1 in two ways. The first, which uses no next router, so it costs one hop. The second requires two hops (A to B, then B to Network 1). The first option has the lowest cost, therefore it is kept and the second one is dropped.
Distance Vector Routing Algorithm
The process of creating the routing table continues for all routers. Every router receives the information from the neighbors, and update the routing table.
Final routing tables of all the routers are given below:




Link State Routing
Link state routing is a technique in which each router shares the knowledge of its neighborhood with every other router in the internetwork.

The three keys to understand the Link State Routing algorithm:

Knowledge about the neighborhood: Instead of sending its routing table, a router sends the information about its neighborhood only. A router broadcast its identities and cost of the directly attached links to other routers.
Flooding: Each router sends the information to every other router on the internetwork except its neighbors. This process is known as Flooding. Every router that receives the packet sends the copies to all its neighbors. Finally, each and every router receives a copy of the same information.
Information sharing: A router sends the information to every other router only when the change occurs in the information.
Link State Routing has two phases:
Reliable Flooding
Initial state: Each node knows the cost of its neighbors.
Final state: Each node knows the entire graph.
Route Calculation
Each node uses Dijkstra's algorithm on the graph to calculate the optimal routes to all nodes.

The Link state routing algorithm is also known as Dijkstra's algorithm which is used to find the shortest path from one node to every other node in the network.
The Dijkstra's algorithm is an iterative, and it has the property that after kth iteration of the algorithm, the least cost paths are well known for k destination nodes.
Let's describe some notations:
c( i , j): Link cost from node i to node j. If i and j nodes are not directly linked, then c(i , j) = ∞.
D(v): It defines the cost of the path from source code to destination v that has the least cost currently.
P(v): It defines the previous node (neighbor of v) along with current least cost path from source to v.
N: It is the total number of nodes available in the network.
Algorithm
Initialization
N = {A}     // A is a root node.
for all nodes v
if v adjacent to A
then D(v) = c(A,v)
else D(v) = infinity
loop
find w not in N such that D(w) is a minimum.
Add w to N
Update D(v) for all v adjacent to w and not in N:
D(v) = min(D(v) , D(w) + c(w,v))
Until all nodes in N
In the above algorithm, an initialization step is followed by the loop. The number of times the loop is executed is equal to the total number of nodes available in the network.

Let's understand through an example:

Link State Routing
In the above figure, source vertex is A.


Step 1:
The first step is an initialization step. The currently known least cost path from A to its directly attached neighbors, B, C, D are 2,5,1 respectively. The cost from A to B is set to 2, from A to D is set to 1 and from A to C is set to 5. The cost from A to E and F are set to infinity as they are not directly linked to A.

Step	N	D(B),P(B)	D(C),P(C)	D(D),P(D)	D(E),P(E)	D(F),P(F)
1	A	2,A	5,A	1,A	∞	∞
Step 2:
In the above table, we observe that vertex D contains the least cost path in step 1. Therefore, it is added in N. Now, we need to determine a least-cost path through D vertex.

a) Calculating shortest path from A to B

v = B, w = D  
D(B) = min( D(B) , D(D) + c(D,B) )  
     = min( 2, 1+2)>  
     = min( 2, 3)  
The minimum value is 2. Therefore, the currently shortest path from A to B is 2.  
b) Calculating shortest path from A to C

v = C, w = D  
D(B) = min( D(C) , D(D) + c(D,C) )  
     = min( 5, 1+3)  
     = min( 5, 4)  
The minimum value is 4. Therefore, the currently shortest path from A to C is 4.</p>  
c) Calculating shortest path from A to E

v = E, w = D  
D(B) = min( D(E) , D(D) + c(D,E) )  
     = min( ∞,  1+1)  
     = min(∞, 2)  
The minimum value is 2. Therefore, the currently shortest path from A to E is 2.  
Note: The vertex D has no direct link to vertex E. Therefore, the value of D(F) is infinity.
Step	N	D(B),P(B)	D(C),P(C)	D(D),P(D)	D(E),P(E)	D(F),P(F)
1	A	2,A	5,A	1,A	∞	∞
2	AD	2,A	4,D		2,D	∞
Step 3:
In the above table, we observe that both E and B have the least cost path in step 2. Let's consider the E vertex. Now, we determine the least cost path of remaining vertices through E.

a) Calculating the shortest path from A to B.

v = B, w = E  
D(B) = min( D(B) , D(E) + c(E,B) )  
     = min( 2 , 2+ ∞ )  
     = min( 2, ∞)  
The minimum value is 2. Therefore, the currently shortest path from A to B is 2.  
b) Calculating the shortest path from A to C.

v = C, w = E  
D(B) = min( D(C) , D(E) + c(E,C) )  
     = min( 4 , 2+1 )  
     = min( 4,3)  
The minimum value is 3. Therefore, the currently shortest path from A to C is 3.  
c) Calculating the shortest path from A to F.

v = F, w = E  
D(B) = min( D(F) , D(E) + c(E,F) )  
     = min( ∞ , 2+2 )  
     = min(∞ ,4)  
The minimum value is 4. Therefore, the currently shortest path from A to F is 4.  
Step	N	D(B),P(B)	D(C),P(C)	D(D),P(D)	D(E),P(E)	D(F),P(F)
1	A	2,A	5,A	1,A	∞	∞
2	AD	2,A	4,D		2,D	∞
3	ADE	2,A	3,E			4,E
Step 4:
In the above table, we observe that B vertex has the least cost path in step 3. Therefore, it is added in N. Now, we determine the least cost path of remaining vertices through B.

a) Calculating the shortest path from A to C.

v = C, w = B  
D(B) = min( D(C) , D(B) + c(B,C) )  
     = min( 3 , 2+3 )  
     = min( 3,5)  
The minimum value is 3. Therefore, the currently shortest path from A to C is 3.  
b) Calculating the shortest path from A to F.

v = F, w = B  
D(B) = min( D(F) , D(B) + c(B,F) )  
     = min( 4, ∞)  
     = min(4, ∞)  
The minimum value is 4. Therefore, the currently shortest path from A to F is 4.  
Step	N	D(B),P(B)	D(C),P(C)	D(D),P(D)	D(E),P(E)	D(F),P(F)
1	A	2,A	5,A	1,A	∞	∞
2	AD	2,A	4,D		2,D	∞
3	ADE	2,A	3,E			4,E
4	ADEB		3,E			4,E
Step 5:
In the above table, we observe that C vertex has the least cost path in step 4. Therefore, it is added in N. Now, we determine the least cost path of remaining vertices through C.

a) Calculating the shortest path from A to F.

v = F, w = C  
D(B) = min( D(F) , D(C) + c(C,F) )  
     = min( 4, 3+5)  
     = min(4,8)  
The minimum value is 4. Therefore, the currently shortest path from A to F is 4.  
Step	N	D(B),P(B)	D(C),P(C)	D(D),P(D)	D(E),P(E)	D(F),P(F)
1	A	2,A	5,A	1,A	∞	∞
2	AD	2,A	4,D		2,D	∞
3	ADE	2,A	3,E			4,E
4	ADEB		3,E			4,E
5	ADEBC					4,E
Final table:
Step	N	D(B),P(B)	D(C),P(C)	D(D),P(D)	D(E),P(E)	D(F),P(F)
1	A	2,A	5,A	1,A	∞	∞
2	AD	2,A	4,D		2,D	∞
3	ADE	2,A	3,E			4,E
4	ADEB		3,E			4,E
5	ADEBC					4,E
6	ADEBCF					
Disadvantage:
Heavy traffic is created in Line state routing due to Flooding. Flooding can cause an infinite looping, this problem can be solved by using Time-to-leave field

