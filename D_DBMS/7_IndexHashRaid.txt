Indexing :-
 - Optimize database performance by minimizing number of disk access required when query process
 Index structure :- [ Search Key | Data Reference ]
 - Search key contain copy of primary key or candidate key of table 
 - Data reference contain set of pointer hold actual address of memory location where data stored

 Indexing Method :-
  Ordered indices :- Indices sorted to make searching faster
  
  Primary Index :-
   - Base on primary key where Primary keys unique to each record and contain 1:1 relation between record
   Dense index  :- Index record of every search key value that make searching faster, Require more space to store index
   Sparse index :- Index record appear only for few items not for everyone, if not found than sequential search perform


  Clustering Index :-
   - Group two or more column to get unique value and create index out of them
   - Record which have similar characteristics grouped and indexes are created for these group
   - Ordered data file 
   - Sometime index created on non-primary key column which not be unique for each record
 

  Secondary Index :-
   - As Size of table grows size of mapping also grow which fetch data from database based on address to overcome it
   - Huge range for column selected initially so that mapping size of first level becomes small 
   - Then each range further divided into smaller range
   - Mapping of first level stored in primary memory so that address fetch is faster and second level actual data 
     stored in secondary memory (hard disk)



B+ Tree :-
 - B+ tree balanced binary search tree that follow multi-level index format
 - Leaf node denote actual data pointer and B+ tree ensures that all leaf node remain at same height
 - In B+ tree leaf node linked using link list 
 - Therefore B+ tree support random access as well as sequential access
 
 Structure of B+ Tree :- 
  - In B+ tree, every leaf node is at equal distance from root node 
  - B+ tree is of order n where n is fixed for every B+ tree
  - It contain internal node and leaf node

  Internal node :-
   - Contain at least n/2 record pointers except root node
   - At most internal node of tree contain n pointer

  Leaf node :-
   - Leaf node of B+ tree contain at least n/2 record pointer and n/2 key value
   - At most leaf node contain n record pointer and n key values
   - Every leaf node of B+ tree contain one block pointer P to point to next leaf node
 


Hashing :-
 - Very inefficient to search all index values and reach desired data 
 - Calculate direct location of data record on disk without using index structure
 - Data stored at data blocks whose address generated by using hashing function 
 - Memory location where these records are stored known as data bucket or data block
 - Hash function choose any of column value to generate address 
 - Most time hash function use primary key to generate address of data block 
 - Hash function is simple mathematical function to any complex mathematical function
 - We can even consider primary key itself as address of data block means each row whose address will be the same as
   primary key stored in data block

 
 Static Hashing :-
  - Resultant data bucket address will always be same means if we generate address for EMP_ID =103 using hash function
    mod(5) then it always result in same bucket address 3
  - No change in bucket address
  - Number of data buckets in memory remain constant throughout
  
  Open Hashing :-
   - When hash function generate address at which data already stored then next bucket will be allocated to it 
   - This mechanism is called as Linear Probing.

  Close Hashing :-
   - When buckets are full then new data bucket allocated for same hash result and linked after previous one 
   - This mechanism known as Overflow chaining

 
 Dynamic Hashing :-
  - Overcome problem of static hashing like bucket overflow
  - Data bucket grow or shrink as records increases or decreases known as Extendable hashing method
  
  

RAID :-
 - Redundancy array of independent disk 
 - Used to connect multiple secondary storage device for increased performance, data redundancy or both 
 - Gives ability to survive one or more drive failure depending upon RAID level used
 - It consist of array of disks in which multiple disk are connected to achieve different goal
 - There are 7 levels of RAID schemes from RAID 0, RAID 1, ...., RAID 6

 Characteristics :- 
  - Contain set of physical disk drive
  - OS views these separate disks as single logical disk
  - Data distributed across physical drives of array
  - Redundancy disk capacity used to store parity information
  - In case of disk failure parity information helped to recover data

 
 RAID 0 :- 
  - Provide data stripping means data place across multiple disks 
  - It based on stripping means if one disk fails then all data in array is lost
  - Doesn't provide fault tolerance but increase system performance
  
  Pros of RAID 0 :- 
   - Throughput increased because multiple data request probably not on same disk
   - Full utilizes disk space and provide high performance
   - Requires minimum 2 drives
 
  Cons of RAID 0 :-
   - Doesn't contain any error detection mechanism
   - RAID 0 is not true RAID because it is not fault-tolerance
   - Failure of either disk result in complete data loss in respective array

 
 RAID 1 :- 
  - Mirroring of data as it copies data from drive 1 to drive 2 
  - Provide 100% redundancy in case of failure
  - Only half space of drive is used to store data and other half drive just mirror of already stored data

  Pros of RAID 1 :- 
   - Fault tolerance, If one disk fails then other automatically takes over
   - Array function even if any one of drives fails
 
  Cons of RAID 1 :- 
   - One extra drive required per drive for mirroring so expense higher


 RAID 2 :-
  - Consist of bit-level striping using hamming code parity 
  - Each data bit in word is recorded on separate disk and ECC code of data words stored on different set disk
  - Due to its high cost and complex structure not commercially used 
  - This same performance achieved by RAID 3 at lower cost
  
  Pros of RAID 2 :-
   - Use one designated drive to store parity
   - Use hamming code for error detection
  
  Cons of RAID 2 :-
   - Require additional drive for error detection


 RAID 3 :-
  - Byte-level striping with dedicated parity 
  - Parity information stored for each disk section and written to dedicated parity drive
  - In case of drive failure parity drive accessed and data reconstructed from remaining devices
  - Once failed drive is replaced missing data restored on new drive
  - Data transferred in bul Thus high-speed data transmission is possible
  
  Pros of RAID 3 :-
   - Data regenerated using parity drive
   - It contain high data transfer rates
   - Data accessed in parallel
  
  Cons of RAID 3 :-
   - Required additional drive for parity
   - Give slow performance for operating on small sized file


 RAID 4 :-
  - Consist of block-level stripping with parity disk
  - Instead of duplicating data RAID 4 adopt parity-based approach
  - Allowsrecovery of at most 1 disk failure due to way parity work
  - If more than one disk fail then there is no way to recover data
  - Level 3 and level 4 both are required at least three disks to implement RAID


 RAID 5 :-
  - Slight modification of RAID 4 system that parity rotates among drives
  - It consist of block-level striping with DISTRIBUTED parity
  - Same as RAID 4, allow recovery of at most 1 disk failure 
  - If more than one disk fails, then there is no way for data recovery

  Pros of RAID 5 :
   - Cost effective and provide high performance
   - Parity distributed across disks in an array
   - Make random write performance better
  
  Cons of RAID 5 :
   - Disk failure recovery takes longer time as parity has to be calculated from all available drives
   - Cannot survive in concurrent drive failure


 RAID 6 :- 
  - Extension of RAID 5 contain block-level stripping with 2 parity bits
  - Survive 2 concurrent disk failures 
  - When disk fail need to replace failed disk because if simultaneously another disk fail then won't be able to 
    recover any data
  
  Pros of RAID 6 :-
   - Perform RAID 0 to strip data and RAID 1 to mirror
   - Stripping performed before mirroring
   - Drives required should be multiple of 2
  
  Cons of RAID 6 :-
   - Not utilized 100% disk capability as half used for mirroring
   - It contain very limited scalability
