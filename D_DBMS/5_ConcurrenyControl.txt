Concurrency Control :- 
 - When multiple user access same database at time known as concurrent execution of database 
 - Recovery with Concurrent Transaction used Checkpoint concept  
 - Thomas write Rule Provide guarantee of serializability order for protocol and improve Basic Timestamp Ordering Algo

 Problems with Concurrent Execution :-
  Lost Update Problem (W - W Conflict):- Read/write in interleaved manner make database inconsistent
  Dirty Read Problem (W-R Conflict)   :- One transaction update but failed before rollback another transaction access   
  Unrepeatable Read Problem (W-R Conflict) | Inconsistent Retrievals Problem :- Two different value read same data

 

Concurrency Control Protocol :-
 - Concept that controlling and managing concurrent execution thus avoiding inconsistencies in database 
 - Ensure ACID property and serializability of concurrent execution of database transaction 

 Lock-Based Protocol :-
  - Any transaction cannot read or write data until it acquire appropriate lock on it 
  - Maintain transaction at time of execution
  - Lock exclusive and multiple transactions not modify same data simultaneously
   
  Types of lock :-
   Shared lock    :- Data item only read by transactionc| Shared between transaction 
   Exclusive lock :- Data item both read as well as written by transaction
   Binary Lock    :- Lock on data item in two state either locked or unlocked


  Types of lock protocols :- 
   Simplistic lock          :- All transaction get lock on data before insert, delete or update on it 
   Pre-claiming Lock        :- Evaluate transaction to list all data item on which they need lock
   Strict Two-phase locking :- First all lock than Releases all locks at time transaction commit
   Two-phase locking (2PL)  :- Transaction acquire all lock, cannot demand any new locks only releases acquired lock
    Growing phase   :- New lock on data item acquired by transaction but none released
    Shrinking phase :- Existing lock held by transaction may be released but no new lock acquired
    
 
 Timestamp Ordering Protocol :-
  - Each transaction issued timestamp and Start working as soon as transaction created use system time
  - Transaction order based on their Timestamp means ascending order of transaction creation
  - Older transaction priority higher execute first 
  - Ensure serializability, freedom from deadlock means no transaction ever wait
  - But schedule may not be recoverable and even be cascade-free


 Validation Based Protocol | Optimistic concurrency control:-
  Read phase :- 
   - Transaction T read values and store in temporary local variable for read
   - Perform all write operation on temporary variable without update to actual database

  Validation phase :- Temporary variable value validated against actual data
  Write phase      :- Temporary result written to database or system otherwise transaction rolled back

  Each phase has different timestamp :-
   Start(Ti)       : Ti started its execution.
   Validation (Ti) : Ti finishes its read phase and starts its validation phase
   Finish(Ti)      : Ti finishes its write phase
   TS(T) = validation(T)

   - Serializability determined during validation process can't be decided in advance
   - While executing transaction ensure greater degree of concurrency less number of conflict



Multiple Granularity :
 Granularity : Size of data item allowed to lock

 Multiple Granularity :-
  - Hierarchically breaking up database into blocks which locked
  - Enhance concurrency and reduces lock overhead
  - Decide either lock data item or unlock data item 
 