Transaction property :-
 - Used to maintain consistency in database before and after transaction

 Atomicity :- 
  - If any operation performed on data either performed or executed completely or should not be executed at all
  - Transaction need to complete till commit if fails it rollback
  - Failed transaction not be resumed but restart

 Consistency :- 
  - Value should remain preserved always 
  - If change in database made, it should remain preserved always 
   
 Isolation(Separation) :- 
  - Data should not affect other one and may occur concurrently
  - Operation on one database should begin when operation on first database get complete 
  - If two operation performed on two different database, they not affect value of one another 
  - When occur simultaneously consistency should remain maintained 
  - Any changes occur in any particular transaction not be seen by other transaction until change not committed in memory

 Durability :- 
  - Ensure data after successful execution of operation become permanent store in database 
  - Even if system fails or leads to crash database still survives



States of Transaction :-  
 Active state        :- First state of every transaction where transaction being executed
 Partially committed :- Transaction executes its final operation but data still not saved to database
 Committed :- Execute all operation successfully and Change permanently saved on database system
 Failed    :- Any checks made by database recovery system fail then transaction said to be in failed state
 Aborted   :- 
  - Transaction reached failed state then recovery system make sure database in previous consistent state
  - If not then it abort or roll back transaction to bring database into consistent state
  - After aborting transaction recovery module select one of two operation :- Re-start transaction | Kill transaction



Schedule :-
 - Series of operation from one transaction to another transaction known as schedule 
 - Used to preserve order of operation in each individual transaction

 Serial Schedule :- 
  - One transaction executed completely before starting another transaction 
  
 Non-serial Schedule :-
  - If interleaving of operation allowed then there will be non-serial schedule
  - Contain many possible order in which system execute individual operation of transaction

 Serializable schedule :-
  - Find non-serial schedule that allow transaction to execute concurrently without interfering with one another
  - It identifiewhich schedule correct when execution of transaction have interleaving of their operation
  - Non-serial schedule serializable if its result equal to result of its transaction executed serially



Testing Serializability :-
 - Test Serializability of schedule
 - If precedence graph contain single edge Ti â†’ Tj then all instruction of Ti executed before first instruction of Tj
 - If precedence graph for schedule S contain cycle then S is non-serializable 
 - If precedence graph has no cycle then S known as serializable



Conflict Serializable Schedule :-
 - Schedule is called conflict serializability if after swapping of non-conflicting operations, it transform into 
   serial schedule
 - Schedule will be conflict serializable if conflict equivalent to serial schedule
 
 Conflicting Operation :- Both belong to separate transaction | Same data item | Contain at least one write operation

 Conflict Equivalent :-
  - One transformed to another by swapping non-conflicting operations
  - Two schedule conflict equivalent :- Contain same set of transaction | Each pair operation ordered same way



View Serializability :-
 - Schedule view serializable if its view equivalent to serial schedule
 - If A schedule conflict serializable then it will be view serializable
 - View serializable does not conflict serializable contains blind write
 
 View Equivalent :-
  Initial Read :- Both schedule must be the same 
  Updated Read :- 
  Final Write  :-

  Step 1: final updation on data items
  Step 2: Initial Read
  Step 3: Final Write



Recoverability of Schedule :- 
 - Sometime transaction not execute completely due to software issue, system crash or hardware failure 
 - In that case, failed transaction has to be rollback 
 
 Irrecoverable schedule :- 
  - If Tj read updated value of Ti and Tj committed before Ti commit

 Recoverable with cascading rollback :- 
  - If Tj read updated value of Ti and Commit of Tj delayed till commit of Ti



Failure Classification :-
 - To find where problem has occurred, generalize failure into following categories :-

 Transaction failure :-
  - Occur when it fail to execute or when it reache point from where it can't go any further 
  - If few transaction or process is hurt, then its called transaction failure

  Reason for transaction failure :-  
   Logical error :- If transaction cannot complete due to some code error or internal error
   Syntax error :- When DBMS itself terminate active transaction because system not able to execute it 
   
 
 System Crash :-
  - System failure occur due to power failure or other hardware or software failure Ex :- OS error
  Fail-stop assumption :- In system crash, non-volatile storage assumed not to be corrupted


 Disk Failure :-
  - Storage drive fail frequently
  - Due to formation of bad sector, disk head crash and unreachability which destroy all or part of disk storage



Log-Based Recovery :-
 - Log is sequence of record 
 - Log of each transaction maintained in some stable storage so that if any failure occur then it recovered from there
 - Any operation performed on database then it will be recorded in log

 Deferred database modification :-
  - If transaction does not modify database until it has committed
  - All logs created and stored in stable storage and database updated when transaction commit
 
 Immediate database modification :-
  - If database modification occurs while transaction is still active
  - Database modified immediately after every operation 
  
 
 Recovery using Log record :-
  - When system crashed then system consult log to find which transaction need to be undone and redone
  


Checkpoint :-
 - All previous logs removed from system and permanently stored in storage disk(Like bookmark)
 - While transaction execution such checkpoint are marked and transaction executed then using step of transaction 
   log files will be created.
 - When it reaches to checkpoint then transaction updated into database and till that point entire log file removed 
   from file 
 - Then log file updated with new step of transaction till next checkpoint
 
 Recovery using Checkpoint :-
  - Read log files from end to start and maintain two list redo-list and an undo-list



Deadlock in DBMS :-
 - Two or more transaction waiting indefinitely for one another to give up locks 
 
 
 Deadlock Avoidance :-
  - Detect any deadlock situation in advance 
  - Wait for graph used for detecting deadlock situation but this method suitable only for smaller database
  - For larger database, deadlock prevention method used
 

 Deadlock Detection :-
  - DBMS should detect whether transaction involved in deadlock or not 
  - Lock manager maintain Wait for graph to detect deadlock cycle in database

  Wait for Graph :-
   - Method for deadlock detection 
   - Graph is created based on transaction and their lock 
   - If created graph has cycle or closed loop then there is deadlock
   - Wait for graph maintained by system for every transaction which waiting for some data hold by other
 
 
 Deadlock Prevention :-
  - If resources allocated in such way that deadlock never occur then deadlock can be prevented
  - DBMS analyze operation of transaction whether they create deadlock situation or not 
  - If they do then DBMS never allowed that transaction to be executed

  Wait-Die scheme :-
   - If transaction requests for A resource which already held with A conflicting lock by another transaction then
     DBMS simply check timestamp of both transaction 
   - Allow older transaction to wait until resource available for execution

  Wound wait scheme :-
   - Older transaction request for resource which held by younger transaction then older transaction forces younger 
     one to kill transaction and release resource 
   - After minute delay younger transaction restarted but with same timestamp
   - If older transaction held resource which requested by Younger transaction then younger transaction asked to wait
     until older releases it
