Transaction :-
 - Single logical unit of work which accesses and possible modifies content of database
 - Set of operation called transaction

 State of Transaction :-  
  Active state        :- First state of every transaction where transaction being executed
  Partially committed :- Transaction executes its final operation but data still not saved to database
  Committed :- Execute all operation successfully and Change permanently saved on database system
  Failed    :- Any checks made by database recovery system fail then transaction said to be in failed state
  Aborted   :- 
   - Transaction reached failed state then recovery system make sure database in previous consistent state
   - If not then it abort or roll back transaction to bring database into consistent state
   - After aborting transaction recovery module select one of two operation :- Re-start transaction | Kill transaction
  Terminated :-  



Transaction property :-
 - Used to maintain consistency in database before and after transaction

 Atomicity :- 
  - If any operation performed on data either executed completely or not executed
  - Transaction need to complete till commit if fails it rollback
  - Failed transaction not be resumed but restart
  Operation :- Abort(No Change) | Commit(Save Transaction)

 Consistency :- 
  - Value should remain preserved always 
  - If change in database made, it should remain preserved always 
   
 Isolation(Separation) :- 
  - Data should not affect one other and may occur concurrently
  - Operation on one database should begin when operation on first database get complete 
  - If two operation performed on two different database, they not affect value of one another 
  - When occur simultaneously consistency should remain maintained 
  - Any changes occur in any particular transaction not be seen by other transaction until change not committed in memory

 Durability :- 
  - Ensure data after successful execution of operation become permanent store in database 
  - Even if system fails or leads to crash database still survives



Schedule :-
 - Maintain Series order of operation from one transaction to another transaction known as schedule 

 Serial Schedule     :- One transaction executed completely before starting another transaction 
 Non-serial Schedule :- If interleaving of operation allowed then there will be non-serial schedule
 
 Serializable Schedule :-
  - Non-serial schedule that allow transaction to execute concurrently without interfering with one another
  - It identifie which schedule correct when execution of transaction have interleaving of their operation
  - Non-serial schedule serializable if its result equal to result of its transaction executed serially

  Testing Serializability :-
   - If graph contain single edge Ti â†’ Tj then all instruction of Ti executed before first instruction of Tj
   - Schedule S contain cycle then S is non-serializable 
   - No cycle then S known as serializable

  

Failure Transaction :-
 - To find where problem has occurred
 - Sometime transaction not execute completely due to software issue, system crash or hardware failure 
 - In that case, failed transaction has to be rollback 
 

 Transaction failure :-
  - Occur when it fail to execute or when it reach point from where it can't go any further 
  - If few transaction or process hurt then its called transaction failure

  Reason for transaction failure :-  
   Logical error :- If transaction cannot complete due to some code error or internal error
   Syntax error :- When DBMS itself terminate active transaction because system not able to execute it 
   
 
 System Crash :-
  - System failure occur due to power failure or other hardware or software failure Ex :- OS error
  Fail-stop assumption :- In system crash, non-volatile storage assumed not to be corrupted


 Disk Failure :-
  - Storage drive fail frequently
  - Due to formation of bad sector, disk head crash and unreachability which destroy all or part of disk storage



Log-Based Recovery :-
 - Log is sequence of record, Any operation performed on database then it will be recorded in log
 - Log of each transaction maintained in some stable storage so that if any failure occur then it recovered from there
 - All logs created and stored in stable storage and database updated when transaction commit

 Deferred database modification  :- Transaction not modify database until it committed
 Immediate database modification :- Database modification occur while transaction still active
 
 Recovery using Log record :- 
  - When system crashed then system consult log to find which transaction need to be undone and redone
  


Checkpoint :-
 - All previous logs removed from system and permanently stored in storage disk(Like bookmark)
 - While transaction execution such checkpoint log files will be created
 - When reache to checkpoint then transaction updated into database and till that point entire log file remove from file 
 - Then log file updated with new step of transaction till next checkpoint
 
 Recovery using Checkpoint :- Read log file from end to start and maintain two list redo-list and an undo-list



Deadlock in DBMS :-
 - Two or more transaction waiting indefinitely for one another to give up lock
 
 Deadlock Avoidance :-
  - Detect any deadlock situation in advance 
  - Wait for graph used for detecting deadlock situation but this method suitable only for smaller database
  - For larger database, deadlock prevention method used
 
 Deadlock Detection :-
  - DBMS should detect whether transaction involved in deadlock or not 
  - Lock manager maintain Wait for graph to detect deadlock cycle in database

  Wait for Graph :-
   - Method for deadlock detection 
   - Graph is created based on transaction and their lock 
   - If created graph has cycle or closed loop then there is deadlock
   - Wait for graph maintained by system for every transaction which waiting for some data hold by other
 
 
 Deadlock Prevention :-
  - If resources allocated in such way that deadlock never occur then deadlock can be prevented
  - DBMS analyze operation of transaction whether they create deadlock situation or not 
  - If they do then DBMS never allowed that transaction to be executed

  Wait-Die scheme :-
   - If transaction requests for A resource which already held with A conflicting lock by another transaction then
     DBMS simply check timestamp of both transaction 
   - Allow older transaction to wait until resource available for execution

  Wound wait scheme :-
   - Older transaction request for resource which held by younger transaction then older transaction forces younger 
     one to kill transaction and release resource 
   - After minute delay younger transaction restarted but with same timestamp
   - If older transaction held resource which requested by Younger transaction then younger transaction asked to wait
     until older releases it
