Unit - 2 :-

 Topics :-
  - What is Process Creation and Termination
  - What is Process?
  - What is Process State
  - What is PCB(Process Control Block)
  - What is Process Scheduling
  - What is Context Switching
  - Inter-Process Communication
  - What is Thread
  - Scheduling Algorithm


 What is Process Creation and Termination :- 
  - When user started executing program it become process
  - Each process has unique id
  - Process may obtain resources either from its parent process or from operating system directly
  - Parent process continues executing with its children process and wait for them to finish
  - Process may be duplicate of its parent process(Same code or data) or may have new program loaded into it
  - Kernal is first process to be created or said to be root of process tree
  - Zoombie process is process that has terminated but its still exists in PCB because its parent has not yet accpted its return value
  - Process termination marks deletation of process or removing process from PCB 
  - Parent process terminate child process If it exceeded its resource usage or its results is no more needed

 

 What is Process :-
  - Process is program execution which defined as entity which represent basic unit of work to be implemented in system
  - Program is passive entity while procrss is active entity
  - When we compare program with process, process is a dynamic instance of program. 
  - When program loaded into memory it become process, it can be divided into four section :-
    Stack : Contain temporary data such as method/function parameters, return address and local variables
    Heap  : Dynamically allocated memory for process during its run time
    Text  : Includes current activity represented by value of Program Counter and contents of processor's registers.
    Data  : Contain global and static variable
    Diagram :- https://www.tutorialspoint.com/operating_system/images/process_components.jpg
  


 What is Process State :-
  - Process state defined current activity process as process executes its state changes
  - Each process represented by Process Control Block(PCB) also called Task Control Block
    
  State :-
   New   :- Initial state when process is first started/created in secondary memory
   Ready :- Process come from secondary memory to main memory(RAM)(Queue) when we start process execution
            Here process is waiting to be assigned to a processor
            Long-term scheduler bring these process from Rom to RAM 
   Running :- Short-term scheduler assign process to processor from ready state and CPU execute process instructions.
              Sometime transfer process to ready state when high-priority process is given by ready state 
              or process exceeded time limit/ time quantum(Round-Robin)
              If process request is I/O request it is transfer to waiting state
   Waiting   :- Process move into these state if it needs to wait for resource, such as waiting for user input or I/O operation
                After complete process its moves into ready state not running 
   Terminate :- Once process finishes its execution, or it is terminated by OS and deallocating all resources 
   Diagram   :- https://www.tutorialspoint.com/operating_system/images/process_state.jpg


 
 What is PCB(Process Control Block) :-  
  - PCB is data structure maintained by Operating System for every process
  - It is identified by an ID(Process ID/PID) 
  - PCB maintained process throughout its lifetime
    PCB Contain All information of process :-
     - Process ID
     - Process Privileges : Required to allow/disallow access to system resources
     - Process State 
     - Pointer            : To parent process
     - Program Counter    : Pointer to the address of next instruction to be executed for this process.
     - CPU Register       : Where process need to be stored for execution for running state
     - CPU scheduling information    : Process priority, other scheduling information, etc. 
     - Memory Management Information 
     - Accounting information        : Includes amount of CPU used for process execution, time limits, execution ID 
     - I/O status information        : List of I/O devices allocated to process.
  


 What is Process Scheduling :-
  - OS maintenance all PCBs in Process Scheduling queues which used to perform process scheduling
    
  OS maintenance following important process scheduling queues :-
    Job Queue     - As process enter system it is put in job queue which keeps all processes in system 
    Ready Queue   - Processes that are residing in memory and are ready for execution are kept in ready queue
                  - It is implemented as linked list of PCBs with header containing pointers to first and last PCBs.
    Device Queue  - List of processes waiting for particular I/O device is called a device queue. 
                  - Each device has its own device queue. 
    Diagram :- https://www.tutorialspoint.com/operating_system/images/queuing_diagram.jpg


  Types of Schedulers :-
   - Schedulers are special system software which handle process scheduling in various ways.
    
   Long-term Scheduler(Job Scheduler) :-
    - When process changes state from new to ready, then there is use of long-term scheduler.
    - Select processes from those submitted by user and loads them into memory for execution
    - It is done by using multiprogramming which represented by number of processes in memory  
    - Long-term scheduler select proper mix of CPU-bound processes and i/o-bound processes. 
    - Multitasking OS like unix and windows not use long-term scheduler they put all new processes in the memory for short-term scheduler
    - Ready Queue handle process queue


   Short-term scheduler(CPU Scheduler) :- 
    - Selects process from ready state(Ready Queue) and allocate CPU to one of them.
    - It is invoked frequently and very fast than long-term scheduler
    - Here Dispatcher which take decision of which process to execute next.  
    - Gives control(PCB information) to cpu to process processes which is selected by CPU scheduler known as Dispatcher
    - CPU Scheduler is invoked when process switches from running state to waiting state OR terminates
    - MS DOS does not support multiprogramming hence no cpu scheduling


   Medium-term scheduler(Swapping):- 
    - Medium-term scheduler invoked due to waiting state is full and need to move process in suspended state
    - Removes processes from memory or suspended it when waiting state(device queue) full due to lots of I/O request 
    - We move process from device queue to secondary memory it is called swapping
    - Remove process from memory and make space for other processes and suspended process moves to secondary storage its called Swapping
    - After complete I/O operation process will be join waiting state if there is space in waiting state otherwie wait for some time


  Types of Scheduling :-
    Non-Preemptive scheduling / cooperating scheduling :-
    - Process keeps in cpu until it terminates(Complete) 
    - Some machine support is :-  Windows 3.1X

    Preemptive scheduling :- 
     - Process can be forced to leave cpu and switch to ready queue due to high-priority process or time quantum
     - Ex :- Unix, Linux, Windows 95 or Higher   


  Scheduling Criteria :-
    ↑ CPU utilization  - Percentage 
    ↑ Throughput       - Number of processes completed per unit time 
    ↓ Turnaround time  - Time from submission to completion (time spent in different queues + time spent in CPU 
                                                               + time spent in different i/o devices) 
    ↓ Waiting time     - Time spent in ready queue (only) 
    ↓ Response time    - Time from submission to first response    



 What is Context Switching :-       
  - Context switching is to store and restore context of CPU in PCB so that process execution can be resumed from same point at later time. 
  - It is essential part of multitasking operating system features which enables multiple processes to share single CPU. 
  - When scheduler switche CPU from executing one process to execute another, state of current running process is stored into PCB 
  - After this state, process next run in own loaded PCB and used set of PC, registers, etc. 
    At that point second process can start executing.
  - To avoid the amount of context switching time, some hardware systems allow two or more sets of processor registers
  - When process is switched following information is stored :-
     - Program Counter
     - Scheduling information
     - Base and limit register value
     - Currently used register
     - Changed State
     - I/O State information
     - Accounting information

 
 
 Inter-Process communication (IPC):-
  - Reason
    - Information sharing
    - Computational Speedup
    - Modularity 
    - Convenience
  - Models
    - Shared Memory
    - Message Passing [Send(p, message) and Receive(id, message)]  



 What is Thread :-
  - Thread is component of process or lightweight process
  - It is smallest sequences of instructions that can be independently managed by CPU scheduler
  - Multiple Thread can exists within same process, executing concurrently and share resources such as memory
  - Threads of process share its instructions(Executable Code) and its context(value of its variable at given any moment)
  - Thread contain thread ID, Program Counter, register set and stack
  - Each thread represent separate flow of control
  - Fork() is system call which used to generate child process(Process clone) :- 2(^n)-1 
  Diagram :- https://www.tutorialspoint.com/operating_system/images/thread_processes.jpg


  Difference between Process and Thread :-
   - Os treat different process differently while all user level thread as single task for OS
   - Context switching between thread typically faster than process
   - In process system call invovled while in thread no system call invovled
   - Blocking process not block another process while blocking thread will block entire process(I/O request so block)
   - Process are typically independent while thread exist as parts of process so it is dependent on process
   - Process contain more state information than threads
   - Different process have different address, data, code whereas threads share same copy of data and code but stack, registers different 
   - Thread share data and code but different stack and registers


  Advantages of Multi-Thread Programming :-
   - Better resource utilization with minimize resources utilization
   - Responsiveness so program Faster execution 
   - Easy communication 
   - Parallelization


  Types Of Thread :-
   User Level 
    - User manage thread where kernel is not aware of existence of thread
    - Thread library manage code for creating, destroying, passing message and data between threads,
      scheduling thread execution and saving and restoring thread contexts.
    - It does not require kernel mode privileges
    - pthread.h library used to create threads
    Diagram :- https://www.tutorialspoint.com/operating_system/images/user_threads.jpg 
  
   Kernel Level :-
    - Kernel maintains context information for process as whole and for individuals threads within process
    - Kernel performs thread creation(similar to create process), scheduling and management in Kernel space using system call. 
    - Simultaneously schedule multiple threads from same process on multiple processes
  
   Difference between User level and Kernel level thread :- 
    - User level thread are managed by user thread library while kernel level managed by OS 
    - User level are faster to create and manage where kernel level is slower to create and manage
    - Context switching in user level thread is faster than kernel level thread
    - If user level thread perform blocking operation then entire process is blocked while in kernel level blocking not affect other
    - User thread Generic and run on any OS while kernel thread OS Specific
    - In User thread Multi-threaded application cannot take advantage of multiprocessing while kernel routine themselves multithreaded

  
  Multi-threading Models :- 
   - Combination of User level thread and Kernel level thread 
   - Combined Threads can run in parallel on multiple processors and blocking system call not block entire process. 
   
   Types :-
   Many To Many Model :-
    - Multiplexes any number of user threads onto equal or smaller number of kernel threads so parallel run on multiprocessor machine
    - Best accuracy and concurrency when thread performs blocking system call, kernel can schedule another thread for execution  
    Diagram :- https://www.tutorialspoint.com/operating_system/images/many_to_many.jpg Ex:- Solaris

   Many To One Model :-
    - Many user level threads to one Kernel-level thread done by thread library 
    - When thread makes blocking system call, entire process will be blocked. 
    - Only one thread can access Kernel at time, so multiple threads are unable to run in parallel on multiprocessors.
    - If user-level thread library not support by OS these mechanisms use
   
   One To One Model :-
    - one-to-one relationship of user-level thread to kernel-level
    - Provide more concurrency than the many-to-one model
    - Allow other thread to run when thread makes blocking system call. 
    - It supports multiple threads to execute in parallel on microprocessors
    - Disadvantage of this model is that creating user thread requires the corresponding Kernel thread
    - Ex :- Linux



 Scheduling Algorithm :-
  - Gantt Chart(Henry Gantt)  Use to sloveing numerical calculation
  - Used to select process for execution 
  - These algorithms either Pre-emptive or Non-Preemptive
  - Non-Preemptive select one process and complete it where pre-emptive select process but in some cases also select other process


  First-Come First-Served(FCFS) Scheduling :-
   - Non-Preemptive
   - High Average Waiting Time
   - Convoy Effect - Several small processes may need to wait if large process is give the cpu   
   - Poor performance and average waiting time is high
   
   Criteria :- Arrival Time : Check Who Come First Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                2                            2              2                     0             0
      p2             1                2                            4              3                     1             1  
      p3             5                3                            8              3                     0             0
      p4             6                4                           12              6                     2             2

    Gantt  :-  p1(0) | p2(2) |  CPU IDle(4) | p3(8) | p4(12)  # Starting 0 + execution time 

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Time at first cpu got first time - Arrival time
    Average Turnaround Time :- 2 + 3 + 3 + 6 = 14/4 = 3.5
    Average Waiting Time    :- 0 + 1 + 0 + 2 = 3/4  = 0.75 



  Shortest-Job-First(SJF) Scheduling :-
   - Process with smallest burst time is selected
   - FCFS to break ties
   - Optimal but cannot be implemented
   - Non-Preemptive 

   Criteria :- Burst Time(Execution Time)Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             1                3                            6              5                     2             2
      p2             2                4                           10              8                     4             4  
      p3             1                2                            3              2                     0             0
      p4             4                4                           14             10                     6             6

    Gantt  :- 0 CPU IDle |1 p3(3) |3  p1(6) |6 p2(10) |10 p4(14)|14       # Starting 0 + execution time but select process bases on execution
            - If two process have same Arrival Time burst time check
            - If two process not have same Arrival Time but already in queue check burst time
            - When both burst time same check arrival time if arrival time same check lower process ID

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Time at first cpu got first time - Arrival time
    Average Turnaround Time :- 5 + 8 + 2 + 10 = 25/4 = 6.25
    Average Waiting Time    :- 2 + 4 + 0 + 6 = 12/4  = 3


  
  Shortest-Job-Remaining Time First(SJF With Preemption) :-
   - Mode Preemptive 

   Criteria :- Burst Time(Execution Time) Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                5                            9              9                     4             0
      p2             1                3                            4              3                     0             0  
      p3             2                4                           13             11                     7             7
      p4             4                1                            5              1                     0             0

    Gantt  :- | p1 -4 | p2 -2 | p2 -1 | p2 0 | p4 0 | p1 0 | p3 0|        
      Cpu  :- 0       1       2       3      4      5      9     13 
           - Starting from 0 and check lower arrival time with 1 execution time
           - If any other lower process arrive and which burst time is lower than previous process 
             add it in cpu otherwise continues old process
           - Add last execution time as completion time

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 24/4 = 6 
    Average Waiting Time    :- 11/4 = 2.75 
 

  
  Priority Scheduling :-
   
   Pre-emptive Priority Scheduling :-
    -    
    Criteria :- Priority Use in Gantt Chart

    Example :-
    Priority Process No ArrivalTime  Burst Time(Execution Time)  Complete Time  TAT(Turnaround Time)  WT(Wait Time)  Response time(RT) 
    10           p1            0                5                       12             12                     7             0
    20           p2            1                4                        8              7                     3             0  
    30           p3            2                2                        4              2                     0             7
    40           p4            4                1                        5              1                     0             0

    Gantt  :-     p1 -4 | p2 -3 | p3 -1 | p3 0 | p4 0 | p2 0 | p1 0 |   # After process its burst time
     Cpu Time :-  0     1       2       3      4      5      8      12
    
          - Higher no higher priority 
          - If two process in ready queue and same arrival time so we need to check priority
          - We process higher priority process here
          - If 2 process have same priority and same arrival time use process id sequence

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 22/4 = 5.5 
    Average Waiting Time    :- 10/4 = 2.5 



  Round-Robin Scheduling :-
   - When process in ready queue then we select it and move in cpu(Running Queue)
   - In RR Scheduling cpu use time quantam and within then time if finish terminate process otherwise send back in running state
   - Here maintenance required on ready queue also 

   Criteria :- Time Quantam Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                5                           12             12                     7             0
      p2             1                4                           11             10                     6             1  
      p3             2                2                            6              4                     2             2
      p4             4                1                            9              5                     0             4

    Give Time Quantam :- 2 
    Ready Queue :- | p1 | p2 | p3 | p1 | p4 | p2 | p1
      Cpu       :- 0    2    

    Gantt       :- | p1 -3 | p2 -2 | p3 0 | p1 -1 | p4 0 | p2 0 | p1 0|
      Cpu       :- 0       2       4      6       8      9     11    12
          
    - How many time context switches happern :- Not calculate first and last cpu time | :- ANs : 6

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 29/4 = 7.25 
    Average Waiting Time    :- 15/4 = 3.75   

 
  
  Multi-level Queue Scheduling :-
   - In real life when we have multiple processes so why single ready queue is used
   - There will be different queues must be for ever process
   - Every process will be have it own algorithms
   - (StarVashion)If too much higher priority process arise than lower level process not executed at time multi-level queue feedback use
   Inter-Queue Scheduling :- Preemptive priority scheduling or RR(80% time for foreground processes and 20% time for background processes)
   
   Diagram :- 
     Highest Priority ---> System Process  --> Round-Robin  ------|
                                                                  |
     Medium Priority  ---> Interactive Process ---> SJF   ------[ CPU ]      
                                                                  |  
     Lowest Priority  ---> Batch Process  -->       FCFS  ------|



  Multi-level Feedback Queue Scheduline :-
   - Lowest priority process give feedback and it slowely slowely update and execute
   - It use for lower priority process