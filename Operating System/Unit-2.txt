Process & Thread & Scheduling Algorithm
 Topics :-
  - What is Process? Its Creation and Termination
  - Process State
  - PCB(Process Control Block)
  - Process Scheduling
  - What is Context Switching
  - Inter-Process Communication
  - What is Thread
  - Scheduling Algorithm



 What is Process? Its Creation, Section and Termination :- 
  Process Creation :-
   - When user started executing program it become process 
   - Program is passive entity while procrss is active entity  
   - Process is dynamic instance of program
   - Process may have new program or may be duplicate of its parent process(Same code or data)
   - Each process has unique id which may obtain resources either from operating system directly or from its parent process
   - Each process has its own address space which contains code, data, stack and heap segments or sections   
   - Parent process continues executing with its child process and wait for them to finish


  Process divided into four section :-
   Stack : Contain temporary data such as method/function parameters, return address and local variables
   Heap  : Dynamically memory allocation for process during Run Time
   Text  : Include current activity represented by value of Program Counter and Content of processor's register
   Data  : Contain global and static variable
   Diagram :- https://www.tutorialspoint.com/operating_system/images/process_components.jpg


   Root Process        :- Kernal is first process created or say Root process of process tree 
   Zoombie process     :- Process is terminated but its still exists in PCB because its parent has not yet accpted its return value


  Process termination :- 
   - Deletation of process or removing process from PCB 
   - Parent process terminate child process If it exceeded its resource usage or its results is no more needed
   - Process terminated normally by completing its task or because fatal error or killed by another process or forcefully killed by user
 
  


 Process State :-
  - Process state defined current activity process, as process executes its state changes
  - Each process represented by Process Control Block(PCB) also called Task Control Block

  State :-
   New   :- Initial state when process is first started/created in secondary memory(ROM)(Job Queue)
   Ready :- Long-term scheduler load Process from secondary memory to main memory(RAM)(Ready Queue)
            where process is waiting to be assigned to processor(CPU)
          - Multiprogramming means number of processes are in ready states to increases CPU utilization
   Running :- Short-term scheduler assign process to CPU from ready state and CPU execute process instructions
              Sometime transfer process to ready state when high-priority process is given by ready state 
              or process exceeded time limit/Time quantum(Round-Robin)
              If process request is I/O request it is transfer to waiting state
   Waiting   :- Process in these state wait for resource, such as waiting for user input or I/O operation
                After complete process its moves into ready state not running 
                If no of process I/O request is increases and (Device queue) is full it is moved into suspended state known as ROM
   Terminate :- Once process finishes its execution, or it is terminated by OS and deallocating all resources 


 

 PCB(Process Control Block) :-  
  - PCB is data structure maintained by Operating System for every process using process ID
  - Entry of all PCBs of current processes is in Process Table 
  - Process Table has status of each and every process that is created in OS along with their PIDs

  PCB Contain All information of process :-
    Process ID
    Process Privileges : Allow/Disallow access to system resources
    Process State      : Contain Function parameters, Local variables and Return address does not contain PID of child process
    Pointer            : To parent process
    Program Counter    : Pointer to the address of next instruction to be executed for this process
    CPU Register       : Process stored for execution(Running state)
    CPU scheduling information    : Process priority, other scheduling information, etc. 
    Memory Management Information 
    Accounting information        : Include amount of CPU used for process execution, time limits, execution ID 
    I/O status information        : List of I/O devices allocated to process
  



 Process Scheduling :-


  Scheduling queues :-
   - OS maintenance all PCBs in Process Scheduling queues to perform process scheduling
   Job Queue     - As Process enter system it put in job queue which keeps all processes in system 
   Ready Queue   - Processes that are residing in memory and are ready for execution are kept in ready queue
                 - It is implemented as linked list of PCBs with header containing pointers to first and last PCBs
   Device Queue  - List of processes waiting for particular I/O resource is called device queue
                 - Each device has its own device queue


  Types of Schedulers :-
   - Schedulers are special system software which handle process scheduling in various ways.
    
   Long-term Scheduler(Job Scheduler) :-
    - LTS used when process change state from new to ready 
    - Select processes from those submitted by user and loads them into memory for execution using multiprogramming
    - LTS select proper mix of CPU-bound processes and I/O-bound processes
    - Multitasking OS like Unix and windows not use long-term scheduler they put all new processes in memory for short-term scheduler
    

   Short-term scheduler(CPU Scheduler) :- 
    - Selects process from ready state(Ready Queue) and allocate CPU to one of them
    - Dispatcher gives PCB information of selected process to cpu to execute process and take decision of which process to execute next
    - CPU Scheduler is invoked when process switches from running state to waiting state OR terminates OR ready state
    - MS DOS does not support multiprogramming hence No cpu scheduling


   Medium-term scheduler(Swapping):- 
    - Invoked when waiting state is full due(device queue) to lots of I/O request and need to move process in suspended state
    - Remove process from RAM and make space for other processes and suspended process moves to secondary storage its called Swapping
    - After complete I/O operation process will be join waiting state if there is space in waiting state otherwie wait for some time


  Types of Scheduling :-
    Non-Preemptive scheduling | Co-Operating scheduling :-
    - Process keeps in cpu until it terminates(Complete) also known as multiprogramming
    - Some machine support is :-  Windows 3.1X

    Preemptive scheduling :- 
     - Process can be forced to leave cpu and switch to ready queue due to high-priority process or time quantum
     - Ex :- Unix, Linux, Windows 95 or Higher   


  Scheduling Criteria :-
    ↑ CPU utilization  - Percentage 
    ↑ Throughput       - Number of processes completed per unit time 
    ↓ Turnaround time  - Time from submission to completion (time spent in different queues + time spent in CPU 
                                                           + time spent in different i/o devices) 
    ↓ Waiting time     - Time spent in ready queue 
    ↓ Response time    - Time from submission to first response    




 What is Context Switching :-       
  - Store and restore context of CPU in PCB so that process execution can be resumed from same point at later time
  - Multitasking OS enables multiple processes to share single CPU
  - When scheduler switch CPU from executing one process to another, state of current running process is stored into PCB 
  - After this state, process next run in own loaded PCB and used set of PC, registers, etc. 
    At that point second process can start executing.
  - To avoid amount of context switching time, some hardware systems allow two or more sets of processor registers
   Information Stored During Switching:-
    - Changed State
    - Program Counter
    - Base and limit register value
    - Currently used register
    - Scheduling information
    - I/O State  information
    - Accounting information



 
 Inter-Process communication (IPC):-
  - Allow processes to communicate with each other and synchronise their actions without using same address space. 
  - IPC can be achieved using shared memory and message passing
  - Reason to use IPC :-
   - Information sharing
   - Computational Speedup
   - Modularity 
   - Convenience
  



 What is Thread :-
  - Smallest sequences of instructions that can be independently managed by CPU scheduler
  - Multiple-Thread can exists within same process, executing concurrently and share resources such as memory
  - Threads of process share its instructions(Executable Code) and its context(value of its variable at given any moment)
  - Thread contain thread ID, Program Counter, register and stack
  - Fork() is system call which used to generate child process(Process clone) :- 2(^n)-1 


  Difference Between Process and Thread :-
    Topic                       Thread                        Process
    Context Switching           Faster                        Slower
    System Call Invovled        No                            Yes
    Independent                 Part of process so dependent  Yes
    State Information           less than process             More than thread
    Blocking                    Block entire process(I/O)     Not block another process
    OS Treating                 All user level thread         Differently
                                as single task  
    Share                       Share same Data and code      Different address, data, code
                                but stack,registers different  
     


  Advantages of Multi-Thread Programming :-
   - Better resource utilization
   - Responsiveness so program Faster execution 
   - Easy communication 
   - Parallelization



  Types Of Thread:-
   
   User Level:-
    - User manage thread where kernel is not aware of existence of thread so not require kernel mode privileges
    - Thread library manage code for creating, destroying, passing message and data between threads, scheduling thread execution 
      and saving and restoring thread contexts.    
    - pthread.h library used to create threads
  
   Kernel Level :-
    - Kernel maintains context information for process as whole and for individuals threads within process
    - Kernel performs thread creation(similar to create process), scheduling and management in Kernel space using system call. 
    - Simultaneously schedule multiple threads from same process on multiple processes
  
   Difference :- 
                      User level                  Kernel level 
    Managed             User                        OS
    Speed to create     Faster                      Slower
    Context Switching   Faster                      Slower
    Perform Blocking    Block entire process        Not Affect Other
    Platform            Independent run any OS      OS Specific
    Multi-Thread        can't take advantage of     kernel routine themselves multithreaded 
                        multiprocessing
  


  
  Multi-threading Models :- 
   - Combination of User level thread and Kernel level thread 
   - Combined Threads can run in parallel on multiple processors and blocking system call not block entire process
   
   Many To Many Model :-
    - Multiplexes any number of user threads into equal or smaller number of kernel threads so parallel run on multiprocessor machine
    - Best accuracy and concurrency when thread performs blocking system call, kernel can schedule another thread for execution  
    Ex:- Solaris

   Many To One Model :-
    - Many user level threads to one Kernel-level thread done by thread library 
    - When thread makes blocking system call, entire process will be blocked
    - Only one thread can access Kernel at time, so multiple threads are unable to run in parallel on multiprocessors
    - If user-level thread library not support by OS these mechanisms use
   
   One To One Model :-
    - one-to-one relationship of user-level thread to kernel-level
    - More concurrency than many-to-one model
    - Allow other thread to run when thread makes blocking system call. 
    - It supports multiple threads to execute in parallel on microprocessors
    - Disadvantage of this model is that creating user thread requires corresponding Kernel thread
    Ex :- Linux




 Scheduling Algorithm :-
  - Gantt Chart(Henry Gantt) Use to sloveing numerical calculation
  - These algorithms either Pre-emptive or Non-Preemptive


  First-Come First-Served(FCFS) Scheduling :-
   - Non-Preemptive
   - High Average Waiting Time
   - Convoy Effect - Several small processes may need to wait if large process is given cpu   
   - Poor performance and average waiting time is high
   
   Criteria :- Arrival Time : Check Who Come First Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                2                            2              2                     0             0
      p2             1                2                            4              3                     1             1  
      p3             5                3                            8              3                     0             0
      p4             6                4                           12              6                     2             2

    # Starting from 0 
    Gantt  :-  | p1 |  p2  |  CPU IDLE | p3    | p4  | CPU  
               0    2      4           5       8     12

    Turnaround Time         :- Complete Time   - Arrival Time
    Waiting Time            :- Turnaround Time - Burst Time
    Response time           :- First Time CPU got - Arrival time
    Average Turnaround Time :- 2 + 3 + 3 + 6 = 14/4 = 3.5
    Average Waiting Time    :- 0 + 1 + 0 + 2 = 3/4  = 0.75 



  Shortest-Job-First(SJF) Scheduling :-
   - Process with smallest burst time is selected
   - FCFS to break ties
   - Optimal but cannot be implemented
   - Non-Preemptive 

   Criteria :- Burst Time(Execution Time)Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             1                3                            6              5                     2             2
      p2             2                4                           10              8                     4             4  
      p3             1                2                            3              2                     0             0
      p4             4                4                           14             10                     6             6

    Gantt  :- 
      | CPU IDle |  p3  |  p1  |  p2  |  p4  |
      0          1      3      6      10     14
      - If two process have same Arrival Time burst time check
      - Not have same Arrival Time but already in queue check burst time
      - When both burst time and arrival time same check lower process ID

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time           :- First Time CPU got - Arrival time
    Average Turnaround Time :- 5 + 8 + 2 + 10 = 25/4 = 6.25
    Average Waiting Time    :- 2 + 4 + 0 + 6 = 12/4  = 3


  
  Shortest-Job-Remaining Time First(SJF With Preemption) :-
   - Mode Preemptive 

   Criteria :- Burst Time(Execution Time) Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                5                            9              9                     4             0
      p2             1                3                            4              3                     0             0  
      p3             2                4                           13             11                     7             7
      p4             4                1                            5              1                     0             0

    Gantt  :- | p1 -4 | p2 -2 | p2 -1 | p2 0 | p4 0 | p1 0 | p3 0|        
      Cpu  :- 0       1       2       3      4      5      9     13 
           - Starting from 0 and check lower arrival time with 1 execution time
           - If any other lower process arrive and which burst time is lower than previous process 
             add it in cpu otherwise continues old process
           - Add last execution time as completion time

    Turnaround Time         :- Complete Time      - Arrival Time
    Waiting Time            :- Turnaround Time    - Burst Time
    Response time           :- First Time CPU got - Arrival time
    Average Turnaround Time :- 24/4 = 6 
    Average Waiting Time    :- 11/4 = 2.75 
 

  
  Priority Scheduling :-
   
   Pre-emptive Priority Scheduling :-
    -    
    Criteria :- Priority Use in Gantt Chart

    Example :-
    Priority Process No ArrivalTime  Burst Time(Execution Time)  Complete Time  TAT(Turnaround Time)  WT(Wait Time)  Response time(RT) 
    10           p1            0                5                       12             12                     7             0
    20           p2            1                4                        8              7                     3             0  
    30           p3            2                2                        4              2                     0             7
    40           p4            4                1                        5              1                     0             0

    Gantt  :-     p1 -4 | p2 -3 | p3 -1 | p3 0 | p4 0 | p2 0 | p1 0 |   # After process its burst time
     Cpu Time :-  0     1       2       3      4      5      8      12
    
          - Higher no higher priority 
          - If two process in ready queue and same arrival time so we need to check priority
          - We process higher priority process here
          - If 2 process have same priority and same arrival time use process id sequence

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 22/4 = 5.5 
    Average Waiting Time    :- 10/4 = 2.5 



  Round-Robin Scheduling :-
   - When process in ready queue then we select it and move in cpu(Running Queue)
   - In RR Scheduling cpu use time quantam and within then time if finish terminate process otherwise send back in running state
   - Here maintenance required on ready queue also 

   Criteria :- Time Quantam Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                5                           12             12                     7             0
      p2             1                4                           11             10                     6             1  
      p3             2                2                            6              4                     2             2
      p4             4                1                            9              5                     0             4

    Give Time Quantam :- 2 
    Ready Queue :- | p1 | p2 | p3 | p1 | p4 | p2 | p1
      Cpu       :- 0    2    

    Gantt       :- | p1 -3 | p2 -2 | p3 0 | p1 -1 | p4 0 | p2 0 | p1 0|
      Cpu       :- 0       2       4      6       8      9     11    12
          
    - How many time context switches happern :- Not calculate first and last cpu time | :- ANs : 6

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 29/4 = 7.25 
    Average Waiting Time    :- 15/4 = 3.75   

 
  
  Multi-level Queue Scheduling :-
   - In real life when we have multiple processes so why single ready queue is used
   - There will be different queues must be for ever process
   - Every process will be have it own algorithms
   - (StarVashion)If too much higher priority process arise than lower level process not executed at time multi-level queue feedback use
   Inter-Queue Scheduling :- Preemptive priority scheduling or RR(80% time for foreground processes and 20% time for background processes)
   
   Diagram :- 
     Highest Priority ---> System Process  --> Round-Robin  ------|
                                                                  |
     Medium Priority  ---> Interactive Process ---> SJF   ------[ CPU ]      
                                                                  |  
     Lowest Priority  ---> Batch Process  -->       FCFS  ------|



  Multi-level Feedback Queue Scheduline :-
   - Lowest priority process give feedback and it slowely slowely update and execute
   - It use for lower priority process