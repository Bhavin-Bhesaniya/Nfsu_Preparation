Unit - 1 

 What is Computer and Other Defination?
  Computer :- General purpose device that execute sequences of instruction to perform numerical calculations and other tasks. 
  Computer Science  :- Study of computer systems and computer processes
  Computer hardware :- Collection of all physical elements of computer system 
  Computer software :- Collection of all program stored in computer system and executed by computer system

  Software             :- Collection of computer programs, libraries and related data are referred to as a software
  Application Software :- Perform task for user 
  System software      :- Operate and controls computer system and provide platform to run application software
  Computer program     :- Collection of instructions that performs specific task when executed by computer. 
  
  Algorithm   :- Computer program that performs well-defined task 
  Kernel      :- Part of OS which interacts directly with hardware and performs most crucial tasks
  Microkernel :- Support only core OS functionalities
  Shell       :- known as command interpreter which is part of OS that receives command from user and gets them executed 
  BIOS(Basic Input/Output System) :- Stored in EPROM and used by CPU to perform start-up procedures when computer is turned on.



 What is OS?
  - OS is a piece of software that manages all resources of computer system, both hardware and software 
    and provides an environment in which user can execute their program in convenient and efficient manner.
  - OS is program that acts as interface between user and computer hardware and controls execution of all kinds of programs
  - First OS is ATLAS developed by Manchester University in late 1950s and early 1960s based on batch operating systems

   Diagram :- https://www.tutorialspoint.com/operating_system/images/conceptual_view.jpg


 
 OS Structures type :-  
  
  Monolithic Architecture :-   
   - Entire OS working in kernel space. 
   - Kernel provides various services such as memory management, file management, process scheduling etc. using function calls.
   - Execution is so fast and process run completely in single address space
   - It is static single binary file
   - If any service fails its lead to entire system failure and to add new services entire architecture needs to modify
     Example :- MS DOS, Unix, Linux
     Diagram :- https://www.tutorialspoint.com/assets/questions/media/11413/Monolithic%20Kernel.PNG


  Layered Architecture :-
   - OS is broken into number of layers (levels) where every layer has different functionality
   - Bottom layer (layer 0) is the hardware and topmost layer (layer N) is user interface
   - These layers are so designed that each layer uses function of lower level layers only.
   - All layers can be defined separately and interact with each other as required.
   - Change in one layer specification does not affect rest of layers.
   - Layer 1 to 6:- Hardware, CPU Scheduling, Memory Management, Process Management, I/O Buffer, User Program
     Example :- Windows NT
     Diagram :- https://www.tutorialspoint.com/assets/questions/media/11495/Layered%20OS.PNG
    

  Microkernel Architecture :-  
   - Minimum software that is required to correctly implement an operating syste
   - This includes memory, process scheduling mechanisms and basic inter-process communication
   - Designs operating system by removing all non-essential components from kernel and implementing them as system and user programs. 
   - Smaller kernel called the micro-kernel. 
   - All new services need to be added to user space and does not require kernel to be modified which increased security and stability.
   - Thus if any service fails then rest of operating system remains untouched. 
     Example :- MacOS
     Diagram :- https://www.tutorialspoint.com/assets/questions/media/11412/Microkernel%20Operating%20System.PNG


  Modular Architecture :-
   - As name suggests it is type of kernel in which some parts of system core will get allocated in independent files called modules. 
   - This can be added to system at run time. 
   - It usually requires small amount of time of load modules. 
   - If one needs a new module, then they won’t have to recompile.



 Os Duties / Function / Services :- 
   
  Process Management | Process Execution :-
   - Creating, Resuming, Suspending and Deleting Processes 
   - Load program into memory, execute it and Handle it
   - Provide mechanism for process synchronization, Interprocess communication and deadlock handling 
   
  I/O Operation | I/O Management | Device Management :-
   - OS Manage device communication between User and Device via their respective drivers 
   - It Keep tracks of all devices and Program that responsible for this task is known as I/O controller.

  Storage/File management or Manipulation:-
   - Organization of files into directories for easy navigation and usage 
   - Manage file operations like Creating, deleting and manipulating files and directories based on permission mode
   - Free space management, Storage allocation and Disk scheduling 

  Memory management :-
   - Keep track of memory to identify which part being used by which job 
   - Allocating and deallocating memory space of Primary(Main) Memory and Secondary Memory
   - Program must execute in Main Memory(RAM) 

  Communication :-
   - OS also handle routing, connection strategies, problems of contention and security.
   - Both processes can be on one computer or on different computers, but they are connected through computer network
   - Communication may be implemented by two methods, either by Shared Memory or by Message Passing.

  Resource Management :-
   - Manage all kinds of resources both hardware and software using Schedulers

  Error Handling / Error detection :-
   - OS constantly checks errors and takes appropriate action to ensure correct and consistent computing    
 
  Protection / Security :-
   - OS ensures that all access to system resources is controlled
   - Ensures that external I/O devices are protected from invalid access attempt   
 
  Control Over System Performance :-
   - Recording delays between request for service and response from system 
  


 Types of operating systems – 
    Single process operating system    :- MS DOS, 1981
    Multiprogramming operating system  :- Dijkstra, early 1960s
    Multitasking operating system      :- CTSS, MIT, early 1960s 


   Batch Operating System / Batch Processing :-
    - Lack of interaction between user and job.
    - OS define job in predefined sequence of commands, programs and data as a single unit.
    - Jobs are processed in order of submission Ex.:- First Come First Served(FCFS) fashion
    - There is an operator which takes similar jobs having same requirement and group them into batches.
    - When job completes its execution, its memory is released and output job gets copied into output device for later processing.
     
    Example :-
      User ---> Set Job in ROM device ---> Go to operator ---> Operator group similar job and execute 
      ---> One time one process execute (No particular time for output) ---> Output is write to disk and get to user from operator
      ---> User use output in own system for process  
     
    Diagram :- https://www.tutorialspoint.com/operating_system/images/batch_processing.jpg


   Time-Sharing operating system :-
    - Sharing processor time among multiple processes
    - Each task given some time to execute so that all tasks work smoothly
    - OS uses CPU scheduling and multiprogramming to provide each process small portion of time
    - Switching of job in CPU is so fast we feel that different process is executing simultaneously
    - Quick Response Time so Reduce CPU IDLE Time
    - Due to its fast switching Security arise with program and data also with data communication and its reliability 

    Example :-
     3 Process need to execute ---> Share processor time among them (Share is based on scheduling) (Time Quantam)
     

   Distributed Operating System :-
    - Use multiple central processors to serve multiple real-time applications to multiple users.
    - Processors communicate with one another through various communication lines like network connection
    - It also referred as loosely coupled system
    - With resource sharing facility, user at one site may be able to use resources available at another side.
    - Reduction of delays in processing and loading on host computer
    - If these processors connect with local network (Single network) like single server it is called cluster operating system
    - OS distribute computation logics among several physical processors
    - Processors do not share memory or a clock Instead, each processor has its own local memory, storage etc...
    - Main advantage is availability, if any system fail another load balancing that system so its improved Scalability     


   Network Operating System :-
    - Runs on server computer and provides server capability to manage application, user data and other networking functionality
    - Purpose to allow shared file and printer access among multiple computers in a network, 
      typically local area network (LAN), private network or to other networks.
    - Centeralized Server so security managed and software upgrade easily and enable remote access 
    - Dependency on central server, High cost , Regular maintenance and update are some disadvantages


   Real Time operating System :-
    - Real-time operating system (RTOS) fixed time constraints system
    - Defined as data processing system in which time interval required to process and respond to inputs is so small that 
      it controls environment.   
    - Time taken by system to respond input and display required updated information is termed as response time.
    - Time constraint matter lot and can't be delays
    
    Example :- Embedded systems, Robotics, Scientific utilities, etc.
    
    Types :-
     Hard-Real Time System :-
      - Critical tasks needs to complete on time there no place for delays 

     Soft-Real Time System :-
      - Less restrictive with limited utility than hard-real time system


   Embedded Systems :-
    - Work on fixed machine like a.c.
    - You can't customally change its functionality 
 


 OS Processing Type :-

   Multiprogramming :-
    - Multiprogramming increases CPU utilization by keeping multiple jobs(process) in main memory so that CPU always has one to execute
    - OS keeps several jobs in main memory at time and pick one jobs from its job pull using scheduling
    - It is NonPre-emptive scheduling means if we give one process to cpu, cpu will complete that entire process and only after complete
      one process pick another process
    - Sometime cpu will go for I/O operation at that time cpu will pick up another process from job pull So cpu idel time is zero   
    - High efficient cpu utilization and user feels many programs run simultaneously
    - Cpu scheduling is required
    Diagram :- https://www.tutorialspoint.com/operating_system/images/memory_layout.jpg


   Multitasking / Time-Sharing :-
    - Multitasking is logical extension of multiprogramming also known as Time-sharing systems
    - CPU executes multiple tasks by switching among them. 
    - It is pre-emptive means we already give process particular time after than automatically move to second process but
      first process still available if not complete in within given time
    - Response time should be minimal and it's required scheduling 
    Diagram :- https://www.tutorialspoint.com/operating_system/images/multitasking.jpg   


   Spooling(Simultaneous Pheripheral Operations Online) :- 
    - Different Pheripheral devices(I/O Device) can run simultaneously 
    - Provide buffer area in secondary memory which is accessible to I/O devices.
    - It save CPU time and user not need to wait for I/O process
      
    Diagram :- https://www.tutorialspoint.com/operating_system/images/spooling.jpg
 


 What is SystemCall :-
  - If we need to use any system functionality we need to go in kernel mode because we only can access user mode
  - To go in kernel mode we use system call   
  - System call is mechanism using which user program request kernel to access system functionality 
  - User program invokes system calls when it requires such services like accessing I/O devices and communicating other programs.
    
  Type of System Call :- 
   E.x. :- Fork, exec, getpid, getppid, wait, exit. 
    File related                  (Open, read, write) 
    device related                (Hardware)(Print something)
    Information(Process related)  (Display time or other)
    Process Control(load, abort in main memory) Fork --> Process create its child process,
    Communication(Inter-Process communication)  (Pipe, shmget, create/delete connection)
    Security                                    (chmod, umask)
 
  Dual-mode operation :-
    - User mode 
    - Kernel mode / supervisor mode / system mode / privileged mode 
    Mode bit– 0: kernel, 1: user 



 What is Booting :-
  - Booting is process of starting computer and loading kernel.
  - When computer power is turned on Then cpu will move to BIOS(Basic Input Output System) in ROM 
  - BIOS run process power-on self-tests (POST) which check all hardware
  - On POST process successful BIOS load MBR(Master Boot Record) to RAM
  - Now MBR load bootstrap loader to RAM
  - bootstrap loader loads OS, Kernel and much more in RAM
  
  Types :- 
    Hard Booting - Power On system
    Soft Booting - Restart / Ctrl + Alt + Del twice



Unit - 2 :-

 What is process creation and termination :- 
  - When user started executing program it become process
  - Each process has unique id
  - Process may obtain resources either from its parent process or from operating system directly
  - Parent process continues executing with its children process and wait for them to finish
  - Process may be duplicate of its parent process(Same code or data) or may have new program loaded into it
  - Kernal is first process to be created or said to be root of process tree
  - Zoombie process is process that has terminated but its still exists in PCB because its parent has not yet accpted its return value
  - Process termination marks deletation of process or removing process from PCB 
  - Parent process terminate child process If it exceeded its resource usage or its results is no more needed

 

 What is Process :-
  - Process is program execution which defined as entity which represent basic unit of work to be implemented in system
  - Program is passive entity while procrss is active entity
  - When we compare program with process, process is a dynamic instance of program. 
  - When program loaded into memory it become process, it can be divided into four section :-
    Stack : Contain temporary data such as method/function parameters, return address and local variables
    Heap  : Dynamically allocated memory for process during its run time
    Text  : Includes current activity represented by value of Program Counter and contents of processor's registers.
    Data  : Contain global and static variable
    Diagram :- https://www.tutorialspoint.com/operating_system/images/process_components.jpg
  


 What is Process State :-
  - Process state defined current activity process as process executes its state changes
  - Each process represented by Process Control Block(PCB) also called Task Control Block
    
  State :-
   New   :- Initial state when process is first started/created in secondary memory
   Ready :- Process come from secondary memory to main memory(RAM)(Queue) when we start process execution
            Here process is waiting to be assigned to a processor
            Long-term scheduler bring these process from Rom to RAM 
   Running :- Short-term scheduler assign process to processor from ready state and CPU execute process instructions.
              Sometime transfer process to ready state when high-priority process is given by ready state 
              or process exceeded time limit/ time quantum(Round-Robin)
              If process request is I/O request it is transfer to waiting state
   Waiting   :- Process move into these state if it needs to wait for resource, such as waiting for user input or I/O operation
                After complete process its moves into ready state not running 
   Terminate :- Once process finishes its execution, or it is terminated by OS and deallocating all resources 
   Diagram   :- https://www.tutorialspoint.com/operating_system/images/process_state.jpg


 
 What is PCB(Process Control Block) :-  
  - PCB is data structure maintained by Operating System for every process
  - It is identified by an ID(Process ID/PID) 
  - PCB maintained process throughout its lifetime
    PCB Contain All information of process :-
     - Process ID
     - Process Privileges : Required to allow/disallow access to system resources
     - Process State 
     - Pointer            : To parent process
     - Program Counter    : Pointer to the address of next instruction to be executed for this process.
     - CPU Register       : Where process need to be stored for execution for running state
     - CPU scheduling information    : Process priority, other scheduling information, etc. 
     - Memory Management Information 
     - Accounting information        : Includes amount of CPU used for process execution, time limits, execution ID 
     - I/O status information        : List of I/O devices allocated to process.
  


 What is Process scheduling :-
  - OS maintenance all PCBs in Process Scheduling queues which used to perform process scheduling
    
  OS maintenance following important process scheduling queues :-
    Job Queue     - As process enter system it is put in job queue which keeps all processes in system 
    Ready Queue   - Processes that are residing in memory and are ready for execution are kept in ready queue
                  - It is implemented as linked list of PCBs with header containing pointers to first and last PCBs.
    Device Queue  - List of processes waiting for particular I/O device is called a device queue. 
                  - Each device has its own device queue. 
    Diagram :- https://www.tutorialspoint.com/operating_system/images/queuing_diagram.jpg


  Types of Schedulers :-
   - Schedulers are special system software which handle process scheduling in various ways.
    
   Long-term Scheduler(Job Scheduler) :-
    - When process changes state from new to ready, then there is use of long-term scheduler.
    - Select processes from those submitted by user and loads them into memory for execution
    - It is done by using multiprogramming which represented by number of processes in memory  
    - Long-term scheduler select proper mix of CPU-bound processes and i/o-bound processes. 
    - Multitasking OS like unix and windows not use long-term scheduler they put all new processes in the memory for short-term scheduler
    - Ready Queue handle process queue


   Short-term scheduler(CPU Scheduler) :- 
    - Selects process from ready state(Ready Queue) and allocate CPU to one of them.
    - It is invoked frequently and very fast than long-term scheduler
    - Here Dispatcher which take decision of which process to execute next.  
    - Gives control(PCB information) to cpu to process processes which is selected by CPU scheduler known as Dispatcher
    - CPU Scheduler is invoked when process switches from running state to waiting state OR terminates
    - MS DOS does not support multiprogramming hence no cpu scheduling


   Medium-term scheduler(Swapping):- 
    - Medium-term scheduler invoked due to waiting state is full and need to move process in suspended state
    - Removes processes from memory or suspended it when waiting state(device queue) full due to lots of I/O request 
    - We move process from device queue to secondary memory it is called swapping
    - Remove process from memory and make space for other processes and suspended process moves to secondary storage its called Swapping
    - After complete I/O operation process will be join waiting state if there is space in waiting state otherwie wait for some time


  Types of Scheduling :-
    Non-Preemptive scheduling / cooperating scheduling :-
    - Process keeps in cpu until it terminates(Complete) 
    - Some machine support is :-  Windows 3.1X

    Preemptive scheduling :- 
     - Process can be forced to leave cpu and switch to ready queue due to high-priority process or time quantum
     - Ex :- Unix, Linux, Windows 95 or Higher   


  Scheduling Criteria :-
    ↑ CPU utilization  - Percentage 
    ↑ Throughput       - Number of processes completed per unit time 
    ↓ Turnaround time  - Time from submission to completion (time spent in different queues + time spent in CPU 
                                                               + time spent in different i/o devices) 
    ↓ Waiting time     - Time spent in ready queue (only) 
    ↓ Response time    - Time from submission to first response    



 What is Context Switching :-       
  - Context switching is to store and restore context of CPU in PCB so that process execution can be resumed from same point at later time. 
  - It is essential part of multitasking operating system features which enables multiple processes to share single CPU. 
  - When scheduler switche CPU from executing one process to execute another, state of current running process is stored into PCB 
  - After this state, process next run in own loaded PCB and used set of PC, registers, etc. 
    At that point second process can start executing.
  - To avoid the amount of context switching time, some hardware systems allow two or more sets of processor registers
  - When process is switched following information is stored :-
     - Program Counter
     - Scheduling information
     - Base and limit register value
     - Currently used register
     - Changed State
     - I/O State information
     - Accounting information

 
 
 Inter-Process communication :-
  - Reason
    - Information sharing
    - Computational Speedup
    - Modularity 
    - Convenience
  - Models
    - Shared Memory
    - Message Passing [Send(p, message) and Receive(id, message)]  



 What is Thread :-
  - Thread is component of process or lightweight process
  - It is smallest sequences of instructions that can be independently managed by CPU scheduler
  - Multiple Thread can exists within same process, executing concurrently and share resources such as memory
  - Threads of process share its instructions(Executable Code) and its context(value of its variable at given any moment)
  - Thread contain thread ID, Program Counter, register set and stack
  - Each thread represent separate flow of control
  - Fork() is system call which used to generate child process(Process clone) :- 2(^n)-1 
  Diagram :- https://www.tutorialspoint.com/operating_system/images/thread_processes.jpg


  Difference between Process and Thread :-
   - Os treat different process differently while all user level thread as single task for OS
   - Context switching between thread typically faster than process
   - In process system call invovled while in thread no system call invovled
   - Blocking process not block another process while blocking thread will block entire process(I/O request so block)
   - Process are typically independent while thread exist as parts of process so it is dependent on process
   - Process contain more state information than threads
   - Different process have different address, data, code whereas threads share same copy of data and code but stack, registers different 
   - Thread share data and code but different stack and registers


  Advantages of Multi-Thread Programming :-
   - Better resource utilization with minimize resources utilization
   - Responsiveness so program Faster execution 
   - Easy communication 
   - Parallelization


  Types Of Thread :-
   User Level 
    - User manage thread where kernel is not aware of existence of thread
    - Thread library manage code for creating, destroying, passing message and data between threads,
      scheduling thread execution and saving and restoring thread contexts.
    - It does not require kernel mode privileges
    - pthread.h library used to create threads
    Diagram :- https://www.tutorialspoint.com/operating_system/images/user_threads.jpg 
  
   Kernel Level :-
    - Kernel maintains context information for process as whole and for individuals threads within process
    - Kernel performs thread creation(similar to create process), scheduling and management in Kernel space using system call. 
    - Simultaneously schedule multiple threads from same process on multiple processes
  
   Difference between User level and Kernel level thread :- 
    - User level thread are managed by user thread library while kernel level managed by OS 
    - User level are faster to create and manage where kernel level is slower to create and manage
    - Context switching in user level thread is faster than kernel level thread
    - If user level thread perform blocking operation then entire process is blocked while in kernel level blocking not affect other
    - User thread Generic and run on any OS while kernel thread OS Specific
    - In User thread Multi-threaded application cannot take advantage of multiprocessing while kernel routine themselves multithreaded

  
  Multi-threading Models :- 
   - Combination of User level thread and Kernel level thread 
   - Combined Threads can run in parallel on multiple processors and blocking system call not block entire process. 
   
   Types :-
   Many To Many Model :-
    - Multiplexes any number of user threads onto equal or smaller number of kernel threads so parallel run on multiprocessor machine
    - Best accuracy and concurrency when thread performs blocking system call, kernel can schedule another thread for execution  
    Diagram :- https://www.tutorialspoint.com/operating_system/images/many_to_many.jpg Ex:- Solaris

   Many To One Model :-
    - Many user level threads to one Kernel-level thread done by thread library 
    - When thread makes blocking system call, entire process will be blocked. 
    - Only one thread can access Kernel at time, so multiple threads are unable to run in parallel on multiprocessors.
    - If user-level thread library not support by OS these mechanisms use
   
   One To One Model :-
    - one-to-one relationship of user-level thread to kernel-level
    - Provide more concurrency than the many-to-one model
    - Allow other thread to run when thread makes blocking system call. 
    - It supports multiple threads to execute in parallel on microprocessors
    - Disadvantage of this model is that creating user thread requires the corresponding Kernel thread
    - Ex :- Linux



 Scheduling Algorithm :-
  - Gantt Chart(Henry Gantt)  Use to sloveing numerical calculation
  - Used to select process for execution 
  - These algorithms either Pre-emptive or Non-Preemptive
  - Non-Preemptive select one process and complete it where pre-emptive select process but in some cases also select other process


  First-Come First-Served(FCFS) Scheduling :-
   - Non-Preemptive
   - High Average Waiting Time
   - Convoy Effect - Several small processes may need to wait if large process is give the cpu   
   - Poor performance and average waiting time is high
   
   Criteria :- Arrival Time : Check Who Come First Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                2                            2              2                     0             0
      p2             1                2                            4              3                     1             1  
      p3             5                3                            8              3                     0             0
      p4             6                4                           12              6                     2             2

    Gantt  :-  p1(0) | p2(2) |  CPU IDle(4) | p3(8) | p4(12)  # Starting 0 + execution time 

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Time at first cpu got first time - Arrival time
    Average Turnaround Time :- 2 + 3 + 3 + 6 = 14/4 = 3.5
    Average Waiting Time    :- 0 + 1 + 0 + 2 = 3/4  = 0.75 



  Shortest-Job-First(SJF) Scheduling :-
   - Process with smallest burst time is selected
   - FCFS to break ties
   - Optimal but cannot be implemented
   - Non-Preemptive 

   Criteria :- Burst Time(Execution Time)Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             1                3                            6              5                     2             2
      p2             2                4                           10              8                     4             4  
      p3             1                2                            3              2                     0             0
      p4             4                4                           14             10                     6             6

    Gantt  :- 0 CPU IDle |1 p3(3) |3  p1(6) |6 p2(10) |10 p4(14)|14       # Starting 0 + execution time but select process bases on execution
            - If two process have same Arrival Time burst time check
            - If two process not have same Arrival Time but already in queue check burst time
            - When both burst time same check arrival time if arrival time same check lower process ID

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Time at first cpu got first time - Arrival time
    Average Turnaround Time :- 5 + 8 + 2 + 10 = 25/4 = 6.25
    Average Waiting Time    :- 2 + 4 + 0 + 6 = 12/4  = 3


  
  Shortest-Job-Remaining Time First(SJF With Preemption) :-
   - Mode Preemptive 

   Criteria :- Burst Time(Execution Time) Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                5                            9              9                     4             0
      p2             1                3                            4              3                     0             0  
      p3             2                4                           13             11                     7             7
      p4             4                1                            5              1                     0             0

    Gantt  :- | p1 -4 | p2 -2 | p2 -1 | p2 0 | p4 0 | p1 0 | p3 0|        
      Cpu  :- 0       1       2       3      4      5      9     13 
           - Starting from 0 and check lower arrival time with 1 execution time
           - If any other lower process arrive and which burst time is lower than previous process 
             add it in cpu otherwise continues old process
           - Add last execution time as completion time

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 24/4 = 6 
    Average Waiting Time    :- 11/4 = 2.75 
 

  
  Priority Scheduling :-
   
   Pre-emptive Priority Scheduling :-
    -    
    Criteria :- Priority Use in Gantt Chart

    Example :-
    Priority Process No ArrivalTime  Burst Time(Execution Time)  Complete Time  TAT(Turnaround Time)  WT(Wait Time)  Response time(RT) 
    10           p1            0                5                       12             12                     7             0
    20           p2            1                4                        8              7                     3             0  
    30           p3            2                2                        4              2                     0             7
    40           p4            4                1                        5              1                     0             0

    Gantt  :-     p1 -4 | p2 -3 | p3 -1 | p3 0 | p4 0 | p2 0 | p1 0 |   # After process its burst time
     Cpu Time :-  0     1       2       3      4      5      8      12
    
          - Higher no higher priority 
          - If two process in ready queue and same arrival time so we need to check priority
          - We process higher priority process here
          - If 2 process have same priority and same arrival time use process id sequence

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 22/4 = 5.5 
    Average Waiting Time    :- 10/4 = 2.5 



  Round-Robin Scheduling :-
   - When process in ready queue then we select it and move in cpu(Running Queue)
   - In RR Scheduling cpu use time quantam and within then time if finish terminate process otherwise send back in running state
   - Here maintenance required on ready queue also 

   Criteria :- Time Quantam Use in Gantt Chart

   Example :-
    Process No. | Arrival Time | Burst Time(Execution Time) |Complete Time | TAT(Turnaround Time) | WT(Wait Time) | Response time(RT) 
      p1             0                5                           12             12                     7             0
      p2             1                4                           11             10                     6             1  
      p3             2                2                            6              4                     2             2
      p4             4                1                            9              5                     0             4

    Give Time Quantam :- 2 
    Ready Queue :- | p1 | p2 | p3 | p1 | p4 | p2 | p1
      Cpu       :- 0    2    

    Gantt       :- | p1 -3 | p2 -2 | p3 0 | p1 -1 | p4 0 | p2 0 | p1 0|
      Cpu       :- 0       2       4      6       8      9     11    12
          
    - How many time context switches happern :- Not calculate first and last cpu time | :- ANs : 6

    Turnaround Time :- Complete Time   - Arrival Time
    Waiting Time    :- Turnaround Time - Burst Time
    Response time   :- Cpu First time - Arrival time
    Average Turnaround Time :- 29/4 = 7.25 
    Average Waiting Time    :- 15/4 = 3.75   

 
  
  Multi-level Queue Scheduling :-
   - In real life when we have multiple processes so why single ready queue is used
   - There will be different queues must be for ever process
   - Every process will be have it own algorithms
   - (StarVashion)If too much higher priority process arise than lower level process not executed at time multi-level queue feedback use
   Inter-Queue Scheduling :- Preemptive priority scheduling or RR(80% time for foreground processes and 20% time for background processes)
   
   Diagram :- 
     Highest Priority ---> System Process  --> Round-Robin  ------|
                                                                  |
     Medium Priority  ---> Interactive Process ---> SJF   ------[ CPU ]      
                                                                  |  
     Lowest Priority  ---> Batch Process  -->       FCFS  ------|



  Multi-level Feedback Queue Scheduline :-
   - Lowest priority process give feedback and it slowely slowely update and execute
   - It use for lower priority process