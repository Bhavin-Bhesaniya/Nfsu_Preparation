Process Synchronization
 Topics :- 
  - Process Synchronization
  - Race Condition
  - Producer Consumer Problem(Bounded Buffer Problem)
  - Printer- Spooler Problem
  - Critical Section Problem
  - Condition For Synchronization
  - Lock Variable/ Test_and_Set
  - Turn Variable (Strict Alteration)
  - SemaPhores



 What is Process Synchronization :-
  - If multiple processes run parallel there will be two mode either serial mode or parallel mode
  - Serial model single process is executed completely like Non pre-emptive while in parallel mode multiple processes run
  - Process can be categorized into two types :- Cooperative, Independent
  - Cooperative process is type of process where one process execution affect other process execution because their share something
    like variable, memory(Buffer), code and in resource CPU, Printer etc.. 
  - In independent process one process execution does not affect other process execution they not share anything 
  - Due to Cooperative process we need process synchronization otherwise sometime it will create problems



 Race condition :- 
   - Several processes Access and Manipulate same data concurrently and outcome of execution depending on particular order in 
     which accesses take place
   - Due to these lost of data, deadlock and many problems occure
    
    Example :- P1 and P2 process running on same system --> Constraint :UniProcessor
    
      int shared = 5;
        P1             P2
      int X=Shard;       int Y= Shard;
      X++;               Y--;
      Sleep(1);          Sleep(1);      // Sleep means pause process not cpu so cpu move using context switch
      Shared = X;        Shared = Y;
      ANS :- 6           4
    
     - If add one and remove one answer should be 5 but here 4 receive due to Cooperative process   
     - These problem know as race condition



 Producer Consumer Problem (Bounded Buffer Problem):-
   Example :-
    Consumer Code :-                                                
      void consumer(void){                                            
      int itemc;                                                    
      while(true){                                                    
        while(count==0)         // Buffer empty go to infinite loop                                   
        item c = Buffer(Out);                                         
        out = (out+1) mod n;    // Out local variable for buffer            
        count = count - 1;                                              
        process_item(itemc);  }}

    Buffer :- n = 8 | Buffer[0...n-1] |

    Producer Code :- 
    int count = 0;  // Global variable share in both
    void producer(void){
      int itemp;
      while(true){
        produce_item(itemp);
        while(count == n);     // n is size of buffer if true means buffer overflow so we not add any extra item
        Buffer[in] = itemp;  
        in = (in+1) mod n;     // In is local variable for buffer // modn is used to repoisition at zero if full
        count = count - 1; }}


    Case 1 :- Producer produce item --> x1 store In buffer using In variable than In value +1 
              --> count value 1 --> consumer code run --> Consumer consume product in buffer 
              --> out variable +1 --> count value -1 

    How Cpu load process :- convert in microprocess
                            load Rp, m[Count] (RP stored value in register)
                            INCREMENT Rp;
                            Store m[Count], Rp;

    
    Case 2 :- If process not synchronization
    - Producer produce 3 items x1, x2, x3 so in Count = 3 --> Now producer again run time but these time during count value change
      process pre-emptive and go to consumer process so in pcb store process with count 4 --> consumer consume product and decrement count
      but at time process pre-emptive and count = 2 --> go to producer process and count = 4 due to pcb resume process
      --> in consumer process run count =2 but in buffer item = 3 ans we  get ans = 2 
      Flow => i1,i2 -> ci1,ci2 -> i3 -> c3     



 Printer-Spooler Problem :-
   - One printer in network different user use to print where printer is pheripheral device so it is very slower
   - Spooler is program when multiple use print document it goes into spooler diretory and then spooler give one by one program
     to printer sequentially
   
   Code :- If user need to add his document in spooler diretory
    Load Ri, m[in]        // In is shared variable where m[in] memory location of in | Ri is register and i is process id
    Store SD[Ri], "F-N"   // SD is spooler diretory and SD[Ri] Spooler diretory of zero store
    Increment Ri
    Store m[in], Ri 

   Case 1 :- Store f1.doc in IN variable --> IN value = 0 --> It load in m[in] so Ri = 1 --> NoW SD = 1 in spooler diretory
             Ri = 2, m[in] = 2

   Case 2 :- p1 i1,i2,i3 In=3, R1 = 4 | p2 i1,i2,i3,i4 In =4, R2 = 4 | p1 i4 
           - Override file on same location , loss of data 



 Critical Section Problem :-
   - Part of program where shared resources are accessed by various processes(Cooperative)
   - Program has two part :- Critical section, Non-critical section
   - Critical section is place shared variables or resources are placed
   - Critical section enforcing due to two program use different operation on shared variables or resources to avoid:-
      - Add entry barrier(Entry Section) before using critical section                       
      - If one program entry section is passed another program not need to pass entry section
      - After critical section execution there will be exit section 


  
 Condition For Synchronization :-
   - We need to follow 4 Rules or say method need to pass these 4 rules
   - First two Rules are primary rules must need to follow and 3,4 is secondary rules 
   
   Rules :-  
   Mutual Exclusion :-
    - If one process execute critical section we need to stop second process to execute critical section by using entry code section
    - If we achieve it is called Mutual Exclusion means we allow one one process to execute critical section 

   Progress :-
    - If one process is interested to execute critical section but second process is not interested and it not allow 
      first process to execute critical section because second process entry section is not allowing for that so progress is stopped
    - So we need to write code where one process not stoping another process to execute critical section
    - Progress is must in synchronization    

   Bounded Wait :-
    - If one process used critical section they must be condition where that process execute N no. of time only which we given 
      not going in infinite 
    - It must be condition if one process N time execute there must be second process used critical section N time which given   
   
   No Assumption related to hardware or speed :-
    - If we given any solution related process synchronization it not be related to hardware or speed of process
    - It must be portable for all OS
     


 Lock Variable / Test_and_Set :- 
   - To Avoid Critical Problem Solution
   - Execute in User Mode, MultiProcessor Solution, No Mutual Exclusion Gurantee 
   - Main concept is if any on use critical section Acquire lock, work your process and release lock
    
    Example :- 
      do {
        Acquire Lock
        Critical Section
        Release Lock
      }
     
    Pesudo Code :-
      While(Lock == 1);  Entry
      Lock = 1           Code
      Critical Section
      Lock = 0          Exit Code

    Case 1:- Lock = 0 -> Show critical section is empty | Lock = 1 -> Show critical section is full

    Case 2 :- p1 i1 pre-emptive | p2 i1,i2,i3 pre-emptive | come back run p1 i2 (Now lock value overwrite)  
             - If pre-emption occure between i1 and i2 Mutual Exclusion not satisfy


    To achieve Mutual Exclusion Use "Test_and_Set" instructions :-
    - It combined instruction 1 and 2 and make test_and_set instructions so it avoid pre-emptive between i1 and i2
    
    Example :- 
      while(test_and_set(&lock));   // Call by reference we pass address
      critical section
      lock = false;

      boolean test_and_set(boolean *traget){ // target pointer variable 
        boolean r = *traget;
        *traget = True;
        return r;
      }
    
      lock(False/1000) <-- target(1000)  R(False/1000)     
        True



 Turn Variable (Strict Alteration):-   
   - Only work on 2 Process 
   - Run in USER Mode
   - Mutual Exclusion, progress, Bounded wait, Independent are all achieve

   Example :-
    P1                        P2
    While(!turn = 0);         While(!turn = 1);   -> Entry Code
    Critical Section          Critical Section
    turn = 1;                 turn = 0;           -> Exit Code



 SemaPhores :-
  - It is tool or method to prevent race condition
  - SemaPhore it is integer variable which is used in mutual exclusive manner by various concurrent coperative process
    in order to achieve process synchronization
   
  Types :- 
    Counting (-infinite to + infinite)
    Binary   (0,1) By default value is 1

    Operation :-
     P(), Down, Wait                    :- Use in Entry Code and reduce pre-defined value of semaPhore
     V(), Up, Signal, Post, Release     :- Use in Exit Code and plus value of semaPhore


   Example :- 
    - In starting critical section is total free and multiple processes want to enter into critical section
    - In entry section Down() code and Up() code are running

    Down(SemaPhore S){          // U can use any synonymous of Down like P() or Wait() | S is semaPhore Variable Name
      S value = S.value - 1;    // Inital value 3 now S = 2 | Now P2 Come S = 1 | Now P3 Come S = 0 | Now P4 Come S = -1
      if(S.value<0){            // Condition false so P1 go in critical section | Now P2 also go in critical section | P3 also
        Put Process(PCB) in Suspended list, sleep();  // P4 in Sleep Mode or say We Block Process list
      }else{ return; } }  
    
    - If semaPhore value -4 we can estimate that already 4 processes in block list
    - If SemaPhore value 0 no other processes can enter in critical section and No Process in Suspended list or Block List
    - Now if process come from critical section it need to execute exit code (Up())  
    - At present semaPhore value is -1 and in critical section p1,p2,p3 and in block list p4
    - Wake up means convert process from block list to ready queue

    Up(SemaPhore S){          // U can use any synonymous of Up like V() or Signal() or Post() | S is semaPhore Variable Name
      S.value = S.value + 1;  // Now S value = 0 and P4 in ready queue not in critical section it will try to go in critical section 
      if(S.value <=  0){      
        Select Process(PCB) from Suspended list wake up(); 
      }
    }

    - Now P4 try to enter critical section but S = -1 so p4 again in Block List
    - Now p3 come from critical section Now S value = 0
    

    Case 2 :-
     - SemaPhore value is = 10 so 10 process can go in critical section 
     - Now i perform 6P() operation and 4V() operation what will be final result = 10 -6 = 4 + 4 = 8 


  Binary SemaPhore :-  
    - Integer Variable value is either 0 or 1
    - If SemaPhore value inital 1 so process have chance to go in critical section and perform if 0 so process is blocked
    - Not going in -1 because it is binary
    - If inital semaPhore value for all process is 0 then process will be deadlock

    Operation :-
    Down(SemaPhore S){    // S value = 1
      if(S.Value == 1){
        S.Value = 0;     // SuccessFull Operation means process operation in Down S = 0 
      }else{
        Sleep(); // Block These Process and Place in Suspended list
      }
    }
    S = 1 0, 0 0
    S = 0 1, 1 1 

    Up(SemaPhore S){     // S value = 0         
      if(Suspended list is empty){ // If no process is here value 1 otherwise go into else and wakeUp
        S.value = 1;
      }else{
        wakeUp(); // Select Process from Suspended list
      }
    }
   

  Question Solution :- What is maximum no of processes that may present in CS at any point of time?
    - 10 Process pi{i = 1 to 9} execute these code | mutex = 1
     repeat
      p(Mutex) - Entry Code
      cs
      v(mutex) - Exit Code
     forever    
  
    - P10 execute v(mutex) - in entry code and exit code
     repeat
      V(Mutex) - Entry Code
      cs
      V(mutex) - Exit Code
     forever
    
    Case 1 :- Mutex 1 0 1

    Case 2 :- Mutex  1 0 0(P2 block) 
              but P10 run Mutex 0 to 1 so P1,P10 in critical section 
              Mutex 1 0 P2 also in critical section
              P10 release from critical section so Mutex 0 to 1 and P3 in critical section So Mutex 1 to 0
              Now P10 again join and release     
    

  Question Solution :- Producer Consumer Problem Using SemaPhore
   
    
  Question Solution :- Reader Writer Problem Using SemaPhore
  Question Solution :- Dining philosopher Problem Using SemaPhore
