Operating System - I/O Hardware
 - OS manage various I/O devices
 - I/O system take application I/O request and send it to physical device then take response comes back from device 
   and send to application 
 I/O device divided into two categories :- 
  Block device :- Work With driver communicate by sending entire blocks of data 
  Character devices :- With which driver communicates by sending and receiving single character
   

 Device Controllers :-
 - Device drivers are software modules that plugged into OS to handle particular device 
 - OS takes help from device drivers to handle all I/O devices
 - Device Controller works like interface between device and device driver 
 - I/O units (Keyboard, mouse, printer, etc.) typically consist of mechanical component and electronic component 
   where electronic component is called device controller
 - There is always device controller and device driver for each device to communicate with OS 
 - Device controller able to handle multiple devices 
 - As interface its main task to convert serial bit stream to block of bytes to perform error correction as necessary
 - Any device connected to the computer is connected by plug and socket and socket connected to device controller
 - I/O devices where CPU and device controllers all use common bus for communication

 Synchronous vs asynchronous I/O
  Synchronous I/O  - CPU execution waits while I/O proceeds
  Asynchronous I/O - I/O proceeds concurrently with CPU execution

 Communication to I/O Devices :-
  - CPU must pass information to and from I/O device 
  Special Instruction I/O
  Memory-mapped I/O
  Direct memory access (DMA)
 
 Special Instruction I/O :-
  - Made for controlling I/O devices 
  - Allow data to be sent to I/O device or read from I/O device

 Memory-mapped I/O :-
  - Same address space shared by memory and I/O devices 
  - Device connected directly to certain main memory locations so that I/O device transfer block of data to/from memory
    without going through CPU
  - OS allocates buffer in memory and informs I/O device to use that buffer to send data to CPU 
  - I/O device operates asynchronously with CPU, interrupts CPU when finished
  - Advantage is that every instruction which access memory used to manipulate I/O device 
  - Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces

 Direct Memory Access (DMA) :-
  - Slow device generate interrupt to CPU after each byte is transferred 
  - If fast device interrupt for each byte, os spend most of its time handling these interrupts 
  - Direct memory access (DMA) used to reduce this overhead hardware
  - CPU grants I/O module authority to read from or write to memory without involvement 
  - DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred.
  - DMA Access hardware called DMA controller (DMAC) that manages data transfers and arbitrates access to system bus 
  - Controllers are programmed with source and destination pointers (where to read/write the data), counters to track 
    number of transferred bytes and setting which includes I/O and memory types interrupts and states for CPU cycles

  OS uses DMA hardware as follows :-
   - Device driver is instructed to transfer disk data to a buffer address X
   - Device driver then instruct disk controller to transfer data to buffer
   - Disk controller starts DMA transfer
   - Disk controller sends each byte to DMA controller
   - DMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero
   - When C becomes zero, DMA interrupts CPU to signal transfer completion
   - Polling vs Interrupts I/O
   - computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as polling and interrupts. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running.

Polling I/O
Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information.

Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls.

Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance.

Interrupts I/O
An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention.

A device controller puts an interrupt signal on the bus when it needs CPUâ€™s attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted.


I/O Management :-
 - Two main responsibility of computer :- Process and I/O
 - Some process perform more I/O and Minimal Processing
 - I/O devices vary widely in function and speed

 - I/O Subsystem of the kernel separate rest of kernel from complexities of managing I/O Device
 - Device drivers provide uniform device access interface to i/o subsystem
 Diagram :-
                      Kernel                        # 1 to 3 Software
                Kernel I/O Subsystem
    Device Driver-1     ... Device Driver-N
    Device Controller-1 ... Device Controller -N    # Hardware
        Device 1            Device - N


 Types of devices :-
  Storage         :- Disk | USB
  Transmission    :- Modem
  Human-Interface :- Keyboard | Mouse | Display
  Specialized     :- Microscope | Telescope 


 Hardware :-
  Port :- 
   - Connection point where device is connected
   - I/o port consists of :- Status Register | Control Register | Data-in/Out Register 
  
  Bus  :- Set of wires to transfer data and control information
  Controller :- Control port on device


 Modes of Performing I/O :-
  - Polling(Busy-waiting)  |  Interrupt  | DMA (Burst | Cycle Stealing | Direct Virtual Memory Access(DVMA))


 Complementary Devices :-
  - Teletype = Keyboard + Display   |   Photocopier = Scanner + Printer
 

 Virtual Devices :- PDF Printer


 Properties of Device :-
  - Character-Stream versus block
  - Sequential access versus Random access
  - Synchronization versus asynchronous
  - Sharable versus Dedicated
  - Speed
  - Read-only, Write-only, Read-Write


 Service I/O System :-
  - I/O Scheduling  |  Buffering  |  Caching  |  Error Handling  | I/O Protection | Spooling 



I/O Software organized in following layers :-
 User Level Libraries :- Provide simple interface to user program to perform input and output Ex :- stdio C/C++
 Kernel Level Modules :- Provide device driver to interact with device controller and device independent I/O modules 
 Hardware :- Include actual hardware and hardware controller which interact with device drivers and make hardware alive

 - I/O software is device independent and possible to write program that access any I/O device without specify device 

 Diagram :-
    User        User I/O Libraries
    Kernel      Device Independent I/O
                Device Driver 
    Hardware    Device Controller
                Device




Device Drivers :-
  - Software modules that plugged into OS to handle particular device 
  - OS takes help from device drivers to handle all I/O devices 
  - It encapsulate device-dependent code and implement standard interface in such a way that code contain
    device-specific register reads/writes 
  - Device driver written by device's manufacturer and delivered along with device on CD-ROM
  
  Device driver perform following jobs :-
   - Accept request from device independent software above to it
   - Interact with device controller to take and give I/O and perform required error handling
   - Making sure that request is executed successfully
 
 


Interrupt handlers(Interrupt Service Routine - ISR):-
  - Software or callback function in OS or Device Driver, whose execution triggered by reception of interrupt
  - When interrupt happens in order to handle interrupt update data structures and wakes up process that was waiting
    for interrupt to happen
  - Interrupt mechanism accept address(Number that select specific interrupt handling routine/function from small set) 
  - This address offset stored in interrupt vector table 
  - This vector contains memory addresses of specialized interrupt handlers




Device-Independent I/O Software :-
  - Perform I/O function that common to all device and provide uniform interface to user-level software 
  - Its difficult to write completely device independent software but write some modules which common among all device
  List of functions of device-independent I/O Software :-
   - Uniform interfacing for device drivers
   - Device naming | Device protection | Device-independent block size 
   - Buffering(Data coming off device cannot be stored in final destination)
   - Storage allocation on block devices
   - Allocation and releasing dedicated devices
   - Error Reporting
   



User-Space I/O Software :-
  - Libraries that Provide interface to access functionality of kernel or Ultimately interactive with device drivers 
  - Most user-level I/O software consist of library procedures with some exception like spooling system which is way
    of dealing with dedicated I/O devices in multiprogramming system

 
 I/O Libraries :-
  - In user-space provide interface to OS resident device-independent I/O SW
   



Kernel I/O Subsystem :-
 - Responsible to provide many services related to I/O
 
 Scheduling :-
  - Kernel schedules set of I/O requests to determine good order in which to execute them 
  - When application blocking I/O system call request placed on queue for that device 
  - Kernel I/O scheduler re-arranges order of queue to improve overall system efficiency and average response time
    experienced by application

 Buffering :- 
  - Kernel I/O Subsystem maintain memory area known as buffer that stores data while transferred between two device 
  - It is done to cope with speed mismatch between producer and consumer of data stream or to adapt between devices 
    that have different data transfer sizes

 Caching :- 
  - Kernel maintain cache memory (fast) that holds copies of data 
  - Access to cached copy is more efficient than access to original

 Spooling and Device Reservation :- 
  - Spool is buffer that holds output for device such as printer that not accept interleaved data streams 
  - Spooling system copies queued spool files to printer one at time 
  - In some OS spooling managed by system daemon process in other by kernel thread

 Error Handling :- 
  - OS that uses protected memory guard against many kinds of hardware and application errors

